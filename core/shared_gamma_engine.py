"""
Shared Gamma Engine - Common calculations for WATCHTOWER and GLORY
================================================================

Provides shared gamma calculation logic used by both:
- WATCHTOWER (0DTE gamma visualization)
- GLORY (Weekly gamma visualization)

This module reduces code duplication and ensures consistent calculations
across both systems.

Author: AlphaGEX Team
"""

import logging
import math
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field, asdict
from enum import Enum
from zoneinfo import ZoneInfo

logger = logging.getLogger(__name__)

# Timezone
CENTRAL_TZ = ZoneInfo("America/Chicago")


class GammaRegime(Enum):
    """Overall gamma regime classification"""
    POSITIVE = "POSITIVE"
    NEGATIVE = "NEGATIVE"
    NEUTRAL = "NEUTRAL"


class FlipDirection(Enum):
    """Direction of gamma flip"""
    POS_TO_NEG = "POS_TO_NEG"
    NEG_TO_POS = "NEG_TO_POS"


class DangerType(Enum):
    """Type of danger zone"""
    BUILDING = "BUILDING"      # Gamma accumulating rapidly (>+25% in 5 min)
    COLLAPSING = "COLLAPSING"  # Gamma evaporating (<-25% in 5 min)
    SPIKE = "SPIKE"            # Sudden gamma surge (>+15% in 1 min)


class AlertType(Enum):
    """Types of alerts"""
    GAMMA_FLIP = "GAMMA_FLIP"
    REGIME_CHANGE = "REGIME_CHANGE"
    GAMMA_SPIKE = "GAMMA_SPIKE"
    MAGNET_SHIFT = "MAGNET_SHIFT"
    PIN_ZONE_ENTRY = "PIN_ZONE_ENTRY"
    DANGER_ZONE = "DANGER_ZONE"
    GAMMA_COLLAPSE = "GAMMA_COLLAPSE"
    PATTERN_MATCH = "PATTERN_MATCH"


class AlertPriority(Enum):
    """Alert priority levels"""
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"


@dataclass
class StrikeData:
    """Data for a single strike - shared between Watchtower and Glory"""
    strike: float
    net_gamma: float
    call_gamma: float = 0.0
    put_gamma: float = 0.0
    call_oi: int = 0
    put_oi: int = 0
    probability: float = 0.0
    gamma_change_pct: float = 0.0
    roc_1min: float = 0.0
    roc_5min: float = 0.0
    roc_30min: float = 0.0
    roc_1hr: float = 0.0
    roc_4hr: float = 0.0
    roc_trading_day: float = 0.0
    volume: int = 0
    call_iv: float = 0.0
    put_iv: float = 0.0
    is_magnet: bool = False
    magnet_rank: Optional[int] = None
    is_pin: bool = False
    is_danger: bool = False
    danger_type: Optional[str] = None
    gamma_flipped: bool = False
    flip_direction: Optional[str] = None
    previous_net_gamma: float = 0.0

    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class Alert:
    """Alert generated by the system"""
    alert_type: str
    strike: Optional[float]
    message: str
    priority: str
    spot_price: float
    symbol: str = "SPY"
    old_value: Optional[str] = None
    new_value: Optional[str] = None
    triggered_at: datetime = field(default_factory=lambda: datetime.now(CENTRAL_TZ))

    def to_dict(self) -> Dict:
        return {
            'alert_type': self.alert_type,
            'strike': self.strike,
            'message': self.message,
            'priority': self.priority,
            'spot_price': self.spot_price,
            'symbol': self.symbol,
            'old_value': self.old_value,
            'new_value': self.new_value,
            'triggered_at': self.triggered_at.isoformat()
        }


@dataclass
class MarketStructureSignals:
    """Market structure analysis - 9 signals"""
    # Flip point signal
    flip_point_current: Optional[float] = None
    flip_point_prior: Optional[float] = None
    flip_point_direction: str = "UNKNOWN"  # RISING, FALLING, STABLE
    flip_point_implication: str = ""

    # Bounds signal (±1 std)
    bounds_upper: float = 0.0
    bounds_lower: float = 0.0
    bounds_prior_upper: Optional[float] = None
    bounds_prior_lower: Optional[float] = None
    bounds_direction: str = "UNKNOWN"  # SHIFTED_UP, SHIFTED_DOWN, STABLE, MIXED
    bounds_implication: str = ""

    # Width signal
    width_current: float = 0.0
    width_prior: Optional[float] = None
    width_direction: str = "UNKNOWN"  # WIDENING, NARROWING, STABLE
    width_implication: str = ""

    # Walls signal
    call_wall: Optional[float] = None
    put_wall: Optional[float] = None
    walls_asymmetry: Optional[float] = None
    walls_implication: str = ""

    # Intraday signal
    intraday_open_em: Optional[float] = None
    intraday_current_em: float = 0.0
    intraday_direction: str = "UNKNOWN"  # EXPANDING, CONTRACTING, STABLE
    intraday_implication: str = ""

    # VIX regime signal
    vix: float = 0.0
    vix_regime: str = "UNKNOWN"  # LOW, NORMAL, ELEVATED, HIGH, EXTREME
    vix_implication: str = ""

    # Gamma regime signal
    gamma_regime: str = "UNKNOWN"  # POSITIVE, NEGATIVE, NEUTRAL
    gamma_alignment: str = "UNKNOWN"  # MEAN_REVERSION, MOMENTUM, NEUTRAL
    gamma_implication: str = ""

    # GEX momentum signal
    gex_current: Optional[float] = None
    gex_prior: Optional[float] = None
    gex_direction: str = "UNKNOWN"  # STRONG_BULLISH, BULLISH, FADING, BEARISH, STRONG_BEARISH
    gex_conviction: str = "UNKNOWN"
    gex_implication: str = ""

    # Wall break risk signal
    call_wall_risk: str = "UNKNOWN"  # HIGH, ELEVATED, MODERATE, LOW
    put_wall_risk: str = "UNKNOWN"
    wall_break_implication: str = ""

    # Combined signal
    combined_signal: str = ""
    combined_bias: str = ""
    combined_confidence: str = "LOW"
    combined_strategy: str = ""
    combined_warnings: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict:
        return {
            'flip_point': {
                'current': self.flip_point_current,
                'prior': self.flip_point_prior,
                'direction': self.flip_point_direction,
                'implication': self.flip_point_implication
            },
            'bounds': {
                'current_upper': self.bounds_upper,
                'current_lower': self.bounds_lower,
                'prior_upper': self.bounds_prior_upper,
                'prior_lower': self.bounds_prior_lower,
                'direction': self.bounds_direction,
                'implication': self.bounds_implication
            },
            'width': {
                'current_width': self.width_current,
                'prior_width': self.width_prior,
                'direction': self.width_direction,
                'implication': self.width_implication
            },
            'walls': {
                'current_call_wall': self.call_wall,
                'current_put_wall': self.put_wall,
                'asymmetry': self.walls_asymmetry,
                'implication': self.walls_implication
            },
            'intraday': {
                'open_em': self.intraday_open_em,
                'current_em': self.intraday_current_em,
                'direction': self.intraday_direction,
                'implication': self.intraday_implication
            },
            'vix_regime': {
                'vix': self.vix,
                'regime': self.vix_regime,
                'implication': self.vix_implication
            },
            'gamma_regime': {
                'current_regime': self.gamma_regime,
                'alignment': self.gamma_alignment,
                'implication': self.gamma_implication
            },
            'gex_momentum': {
                'current_gex': self.gex_current,
                'prior_gex': self.gex_prior,
                'direction': self.gex_direction,
                'conviction': self.gex_conviction,
                'implication': self.gex_implication
            },
            'wall_break': {
                'call_wall_risk': self.call_wall_risk,
                'put_wall_risk': self.put_wall_risk,
                'implication': self.wall_break_implication
            },
            'combined': {
                'signal': self.combined_signal,
                'bias': self.combined_bias,
                'confidence': self.combined_confidence,
                'strategy': self.combined_strategy,
                'warnings': self.combined_warnings
            }
        }


class SharedGammaEngine:
    """
    Shared gamma calculation engine used by both WATCHTOWER and GLORY.

    Provides:
    - ROC calculations (1m, 5m, 30m, 1hr, 4hr, trading day)
    - Danger zone detection
    - Gamma flip detection
    - Probability calculations (ML hybrid)
    - Magnet and pin identification
    - Market structure analysis (9 signals)
    - Alert generation
    """

    # Thresholds
    ROC_1MIN_SPIKE_THRESHOLD = 15.0      # % for SPIKE danger type
    ROC_5MIN_BUILDING_THRESHOLD = 25.0   # % for BUILDING danger type
    ROC_5MIN_COLLAPSING_THRESHOLD = -25.0  # % for COLLAPSING danger type
    PIN_ZONE_PROXIMITY_PCT = 0.5         # % distance from likely pin
    GAMMA_SPIKE_THRESHOLD = 50.0         # % increase in 5 min for alert
    GAMMA_COLLAPSE_THRESHOLD = -20.0     # % decrease in 10 min for alert

    # VIX regime thresholds
    VIX_LOW_THRESHOLD = 15
    VIX_NORMAL_THRESHOLD = 22
    VIX_ELEVATED_THRESHOLD = 28
    VIX_HIGH_THRESHOLD = 35

    def __init__(self):
        """Initialize shared engine"""
        self._ml_models = None
        self._previous_expected_move: Optional[float] = None
        self._ema_alpha: float = 0.3

    def reset_smoothing(self):
        """Reset EMA smoothing state"""
        self._previous_expected_move = None

    def set_ema_alpha(self, alpha: float):
        """Set EMA smoothing factor"""
        if not 0 < alpha <= 1:
            raise ValueError("Alpha must be between 0 (exclusive) and 1 (inclusive)")
        self._ema_alpha = alpha

    def _get_ml_models(self):
        """Lazy load ML probability models"""
        if self._ml_models is None:
            try:
                from quant.gex_probability_models import GEXProbabilityModels
                self._ml_models = GEXProbabilityModels()
                logger.info("Loaded GEX probability models for shared engine")
            except Exception as e:
                logger.warning(f"Could not load ML models: {e}")
                self._ml_models = False
        return self._ml_models if self._ml_models else None

    # ==================== ROC Calculations ====================

    def calculate_roc(self, current_gamma: float, history: List[Tuple[datetime, float]],
                      minutes: int = 1) -> float:
        """
        Calculate rate of change over specified minutes.

        Args:
            current_gamma: Current gamma value
            history: List of (timestamp, gamma) tuples
            minutes: Lookback period (1, 5, 30, 60, 240)

        Returns:
            Rate of change as percentage
        """
        if not history or len(history) < 2:
            return 0.0

        target_time = datetime.now(CENTRAL_TZ) - timedelta(minutes=minutes)
        old_gamma = None

        for timestamp, gamma in reversed(history):
            if timestamp.tzinfo is None:
                timestamp = timestamp.replace(tzinfo=CENTRAL_TZ)
            if timestamp <= target_time:
                old_gamma = gamma
                break

        if old_gamma is None or old_gamma == 0:
            return 0.0

        roc = ((current_gamma - old_gamma) / abs(old_gamma)) * 100
        return round(roc, 2)

    def calculate_roc_since_open(self, current_gamma: float,
                                  history: List[Tuple[datetime, float]]) -> float:
        """
        Calculate rate of change since market open (8:30 AM CT).

        Args:
            current_gamma: Current gamma value
            history: List of (timestamp, gamma) tuples

        Returns:
            Rate of change as percentage since market open
        """
        if not history or len(history) < 1:
            return 0.0

        now = datetime.now(CENTRAL_TZ)
        market_open = now.replace(hour=8, minute=30, second=0, microsecond=0)

        if now < market_open:
            return 0.0

        open_gamma = None
        for timestamp, gamma in history:
            if timestamp.tzinfo is None:
                timestamp = timestamp.replace(tzinfo=CENTRAL_TZ)
            if timestamp >= market_open:
                open_gamma = gamma
                break

        if open_gamma is None or open_gamma == 0:
            return 0.0

        roc = ((current_gamma - open_gamma) / abs(open_gamma)) * 100
        return round(roc, 2)

    def calculate_all_roc(self, current_gamma: float,
                          history: List[Tuple[datetime, float]]) -> Dict[str, float]:
        """Calculate all ROC timeframes at once"""
        return {
            'roc_1min': self.calculate_roc(current_gamma, history, 1),
            'roc_5min': self.calculate_roc(current_gamma, history, 5),
            'roc_30min': self.calculate_roc(current_gamma, history, 30),
            'roc_1hr': self.calculate_roc(current_gamma, history, 60),
            'roc_4hr': self.calculate_roc(current_gamma, history, 240),
            'roc_trading_day': self.calculate_roc_since_open(current_gamma, history)
        }

    # ==================== Gamma Calculations ====================

    def calculate_net_gamma(self, call_gamma: float, put_gamma: float,
                            call_oi: int = 0, put_oi: int = 0,
                            spot_price: float = 1.0) -> float:
        """
        Calculate net gamma at a strike.

        Net gamma = (call_gamma * call_OI - put_gamma * put_OI) * 100 * spot_price
        """
        call_exposure = abs(call_gamma) * call_oi * 100 if call_oi else abs(call_gamma)
        put_exposure = abs(put_gamma) * put_oi * 100 if put_oi else abs(put_gamma)
        return (call_exposure - put_exposure) * spot_price

    def detect_gamma_flip(self, current_gamma: float,
                          previous_gamma: float) -> Tuple[bool, Optional[str]]:
        """Detect if gamma flipped from positive to negative or vice versa"""
        if previous_gamma is None or previous_gamma == 0:
            return False, None

        if current_gamma > 0 and previous_gamma < 0:
            return True, FlipDirection.NEG_TO_POS.value
        elif current_gamma < 0 and previous_gamma > 0:
            return True, FlipDirection.POS_TO_NEG.value

        return False, None

    def classify_gamma_regime(self, total_net_gamma: float,
                               neutral_threshold: float = 1e9,
                               spot_price: float = 0) -> str:
        """Classify overall gamma regime.

        Args:
            total_net_gamma: Sum of net gamma (gamma × OI × 100 units)
            neutral_threshold: Threshold in GEX-dollar units (default $1B)
            spot_price: When provided, converts gamma-exposure to GEX-dollar units (× spot²)
        """
        # Convert to GEX-dollar units if spot_price is available
        if spot_price > 0:
            gex_value = total_net_gamma * (spot_price ** 2)
        else:
            gex_value = total_net_gamma

        if gex_value > neutral_threshold:
            return GammaRegime.POSITIVE.value
        elif gex_value < -neutral_threshold:
            return GammaRegime.NEGATIVE.value
        else:
            return GammaRegime.NEUTRAL.value

    # ==================== Probability Calculations ====================

    def get_ml_status(self) -> Dict:
        """
        Get ML model status for monitoring.

        Returns:
            Dict with is_trained, model_info, needs_retraining, staleness_hours
        """
        ml_models = self._get_ml_models()
        if not ml_models:
            return {
                'is_trained': False,
                'model_info': None,
                'needs_retraining': True,
                'staleness_hours': None,
                'status': 'NOT_LOADED'
            }

        return {
            'is_trained': ml_models.is_trained,
            'model_info': ml_models.model_info,
            'needs_retraining': ml_models.needs_retraining(),
            'staleness_hours': ml_models.get_model_staleness_hours(),
            'status': 'TRAINED' if ml_models.is_trained else 'NOT_TRAINED'
        }

    def build_gamma_structure(
        self,
        spot_price: float,
        strikes: List[StrikeData],
        flip_point: Optional[float] = None,
        vix: float = 20.0,
        expected_move: float = None
    ) -> Dict:
        """
        Build gamma_structure dict for ML predictions from strike data.

        Args:
            spot_price: Current spot price
            strikes: List of StrikeData objects
            flip_point: Gamma flip point (calculated if not provided)
            vix: Current VIX level
            expected_move: Expected move in dollars

        Returns:
            Dict suitable for ML model predictions
        """
        if not strikes:
            return {}

        # Calculate total gamma
        total_gamma = sum(abs(s.net_gamma) for s in strikes)

        # Calculate net gamma (sum of all)
        net_gamma = sum(s.net_gamma for s in strikes)

        # Find magnets (top 3 by gamma magnitude)
        sorted_strikes = sorted(strikes, key=lambda s: abs(s.net_gamma), reverse=True)
        magnets = [{'strike': s.strike, 'gamma': s.net_gamma} for s in sorted_strikes[:3]]

        # Calculate flip point if not provided
        if flip_point is None:
            # Find where gamma flips from positive to negative
            positive_strikes = [s for s in strikes if s.net_gamma > 0]
            negative_strikes = [s for s in strikes if s.net_gamma < 0]

            if positive_strikes and negative_strikes:
                pos_center = sum(s.strike for s in positive_strikes) / len(positive_strikes)
                neg_center = sum(s.strike for s in negative_strikes) / len(negative_strikes)
                flip_point = (pos_center + neg_center) / 2
            else:
                flip_point = spot_price

        # Determine gamma regime
        if net_gamma > total_gamma * 0.1:
            gamma_regime = 'POSITIVE'
        elif net_gamma < -total_gamma * 0.1:
            gamma_regime = 'NEGATIVE'
        else:
            gamma_regime = 'NEUTRAL'

        # Expected move default
        if expected_move is None:
            expected_move = spot_price * 0.01  # 1% default

        return {
            'net_gamma': net_gamma,
            'total_gamma': total_gamma,
            'flip_point': flip_point,
            'magnets': magnets,
            'vix': vix,
            'gamma_regime': gamma_regime,
            'expected_move': expected_move,
            'spot_price': spot_price
        }

    def calculate_probability_hybrid(self, strike: float, spot_price: float,
                                     net_gamma: float, total_gamma: float,
                                     expected_move: float,
                                     gamma_structure: Dict = None) -> float:
        """
        Calculate probability using hybrid approach: 60% ML + 40% gamma-weighted distance.

        Args:
            strike: Strike price
            spot_price: Current spot price
            net_gamma: Net gamma at this strike
            total_gamma: Total absolute gamma across all strikes
            expected_move: Expected move in dollars
            gamma_structure: Optional structure for ML model (built automatically if not provided)

        Returns:
            Probability as percentage (0-100)
        """
        # Distance component (40% weight)
        distance_from_spot = abs(strike - spot_price)
        gamma_magnitude = abs(net_gamma)

        if total_gamma == 0:
            total_gamma = 1

        gamma_weight = gamma_magnitude / total_gamma

        if expected_move > 0:
            distance_decay = math.exp(-distance_from_spot / expected_move)
        else:
            distance_decay = 1.0 if distance_from_spot == 0 else 0.0

        distance_probability = gamma_weight * distance_decay * 100

        # ML component (60% weight)
        ml_probability = distance_probability
        ml_used = False

        ml_models = self._get_ml_models()
        if ml_models and ml_models.is_trained:
            # Build minimal gamma_structure if not provided
            if gamma_structure is None:
                gamma_structure = {
                    'net_gamma': net_gamma,
                    'total_gamma': total_gamma,
                    'flip_point': spot_price,  # Default to spot if unknown
                    'magnets': [{'strike': strike, 'gamma': net_gamma}],
                    'vix': 20,  # Default VIX
                    'gamma_regime': 'POSITIVE' if net_gamma > 0 else 'NEGATIVE',
                    'expected_move': expected_move
                }

            try:
                ml_result = ml_models.predict_magnet_attraction(
                    strike, spot_price, gamma_structure
                )
                if ml_result and 'probability' in ml_result:
                    ml_probability = ml_result['probability'] * 100
                    ml_used = True
            except Exception as e:
                logger.debug(f"ML prediction failed, using distance only: {e}")

        # Combined probability
        combined = (0.6 * ml_probability) + (0.4 * distance_probability)

        # Log ML usage for monitoring (every 100th call to avoid spam)
        if hasattr(self, '_ml_call_count'):
            self._ml_call_count += 1
        else:
            self._ml_call_count = 1

        if self._ml_call_count % 100 == 0:
            logger.info(f"ML probability: used={ml_used}, calls={self._ml_call_count}")

        return combined

    def calculate_expected_move(self, atm_call_price: float, atm_put_price: float,
                                 apply_smoothing: bool = True) -> float:
        """Calculate expected move from ATM straddle with optional EMA smoothing"""
        raw_em = atm_call_price + atm_put_price

        if not apply_smoothing or raw_em <= 0:
            return raw_em

        if self._previous_expected_move is None:
            smoothed_em = raw_em
        else:
            smoothed_em = (self._ema_alpha * raw_em +
                          (1 - self._ema_alpha) * self._previous_expected_move)

        self._previous_expected_move = smoothed_em
        return smoothed_em

    # ==================== Detection Methods ====================

    def identify_danger_zones(self, strikes: List[StrikeData]) -> List[Dict]:
        """
        Identify danger zones - strikes with rapid gamma changes.

        Thresholds:
        - BUILDING: 5-min ROC > +25%
        - COLLAPSING: 5-min ROC < -25%
        - SPIKE: 1-min ROC > +15%
        """
        danger_zones = []

        for strike_data in strikes:
            danger_type = None

            if strike_data.roc_5min >= self.ROC_5MIN_BUILDING_THRESHOLD:
                danger_type = DangerType.BUILDING.value
            elif strike_data.roc_5min <= self.ROC_5MIN_COLLAPSING_THRESHOLD:
                danger_type = DangerType.COLLAPSING.value
            elif strike_data.roc_1min >= self.ROC_1MIN_SPIKE_THRESHOLD:
                danger_type = DangerType.SPIKE.value

            if danger_type:
                strike_data.is_danger = True
                strike_data.danger_type = danger_type
                danger_zones.append({
                    'strike': strike_data.strike,
                    'danger_type': danger_type,
                    'roc_1min': strike_data.roc_1min,
                    'roc_5min': strike_data.roc_5min
                })

        return danger_zones

    def identify_magnets(self, strikes: List[StrikeData], top_n: int = 3) -> List[Dict]:
        """Identify top N gamma magnets (highest absolute gamma)"""
        sorted_strikes = sorted(strikes, key=lambda s: abs(s.net_gamma), reverse=True)

        magnets = []
        for i, strike_data in enumerate(sorted_strikes[:top_n]):
            magnets.append({
                'rank': i + 1,
                'strike': strike_data.strike,
                'net_gamma': strike_data.net_gamma,
                'probability': strike_data.probability
            })
            strike_data.is_magnet = True
            strike_data.magnet_rank = i + 1

        return magnets

    def identify_pin_strike(self, strikes: List[StrikeData],
                            spot_price: float) -> Tuple[float, float]:
        """
        Identify the likely pin strike.

        Pin score = (probability * 0.4) + (gamma_rank * 0.3) + (proximity_score * 0.3)
        """
        if not strikes:
            return 0.0, 0.0

        best_pin = None
        best_score = -1

        sorted_by_gamma = sorted(strikes, key=lambda s: abs(s.net_gamma), reverse=True)
        gamma_ranks = {s.strike: i + 1 for i, s in enumerate(sorted_by_gamma)}

        for strike_data in strikes:
            prob_score = strike_data.probability / 100
            gamma_rank = gamma_ranks.get(strike_data.strike, len(strikes))
            gamma_score = 1 - (gamma_rank / len(strikes))
            distance = abs(strike_data.strike - spot_price)
            max_distance = max(abs(s.strike - spot_price) for s in strikes) or 1
            proximity_score = 1 - (distance / max_distance)

            pin_score = (prob_score * 0.4) + (gamma_score * 0.3) + (proximity_score * 0.3)

            if pin_score > best_score:
                best_score = pin_score
                best_pin = strike_data

        if best_pin:
            best_pin.is_pin = True
            return best_pin.strike, best_pin.probability

        return 0.0, 0.0

    def detect_pinning_condition(self, strikes: List[StrikeData], spot_price: float,
                                  likely_pin: float, danger_zones: List[Dict]) -> Dict:
        """
        Detect if market is in a pinning condition.

        Pinning detected when:
        1. No danger zones
        2. Spot within 0.5% of pin
        3. Average ROC < 5%
        """
        if not strikes or not likely_pin:
            return {'is_pinning': False}

        has_no_danger = len(danger_zones) == 0
        distance_to_pin_pct = abs(spot_price - likely_pin) / spot_price * 100 if spot_price > 0 else 100
        is_near_pin = distance_to_pin_pct < 0.5

        roc_values = []
        for s in strikes:
            roc_values.extend([abs(s.roc_1min), abs(s.roc_5min)])

        avg_roc = sum(roc_values) / len(roc_values) if roc_values else 0
        is_stable = avg_roc < 5.0

        is_pinning = has_no_danger and (is_near_pin or is_stable)

        if is_pinning:
            if is_near_pin:
                message = f"PINNING: Price pinning near ${likely_pin} (within {distance_to_pin_pct:.2f}%). Gamma stable."
            else:
                message = f"STABLE: Low gamma movement (avg ROC: {avg_roc:.1f}%). Likely to pin at ${likely_pin}."

            return {
                'is_pinning': True,
                'pin_strike': likely_pin,
                'distance_to_pin_pct': round(distance_to_pin_pct, 2),
                'avg_roc': round(avg_roc, 2),
                'message': message,
                'trade_idea': 'Iron Condor or Credit Spread around pin strike may be favorable.'
            }

        return {'is_pinning': False}

    # ==================== Market Structure Analysis ====================

    def classify_vix_regime(self, vix: float) -> Tuple[str, str]:
        """
        Classify VIX regime and return implication.

        Returns:
            Tuple of (regime, implication)
        """
        if vix < self.VIX_LOW_THRESHOLD:
            return "LOW", "Thin premiums, favor directional plays over Iron Condors"
        elif vix < self.VIX_NORMAL_THRESHOLD:
            return "NORMAL", "Ideal for Iron Condors, balanced risk/reward"
        elif vix < self.VIX_ELEVATED_THRESHOLD:
            return "ELEVATED", "Widen IC strikes, increase premium targets"
        elif vix < self.VIX_HIGH_THRESHOLD:
            return "HIGH", "Reduce position size by 50%, expect volatility"
        else:
            return "EXTREME", "Skip Iron Condors, small directional only"

    def calculate_market_structure(self, spot_price: float, vix: float,
                                    expected_move: float, total_net_gamma: float,
                                    strikes: List[StrikeData],
                                    prior_data: Dict = None) -> MarketStructureSignals:
        """
        Calculate all 9 market structure signals.

        Args:
            spot_price: Current spot price
            vix: Current VIX level
            expected_move: Expected move in dollars
            total_net_gamma: Total net gamma
            strikes: List of strike data
            prior_data: Optional prior day/period data for comparison

        Returns:
            MarketStructureSignals with all 9 signals populated
        """
        signals = MarketStructureSignals()

        prior_data = prior_data or {}

        # 1. VIX Regime
        signals.vix = vix
        signals.vix_regime, signals.vix_implication = self.classify_vix_regime(vix)

        # 2. Gamma Regime
        signals.gamma_regime = self.classify_gamma_regime(total_net_gamma, spot_price=spot_price)
        if signals.gamma_regime == "POSITIVE":
            signals.gamma_alignment = "MEAN_REVERSION"
            signals.gamma_implication = "Dealers hedge against price, expect mean reversion"
        elif signals.gamma_regime == "NEGATIVE":
            signals.gamma_alignment = "MOMENTUM"
            signals.gamma_implication = "Dealers hedge with price, momentum amplified"
        else:
            signals.gamma_alignment = "NEUTRAL"
            signals.gamma_implication = "Balanced dealer positioning, choppy action"

        # 3. Bounds (±1 std expected move)
        signals.bounds_upper = spot_price + expected_move
        signals.bounds_lower = spot_price - expected_move
        signals.width_current = expected_move * 2

        if prior_data.get('bounds_upper') and prior_data.get('bounds_lower'):
            signals.bounds_prior_upper = prior_data['bounds_upper']
            signals.bounds_prior_lower = prior_data['bounds_lower']
            signals.width_prior = prior_data.get('width', signals.width_current)

            upper_change = signals.bounds_upper - signals.bounds_prior_upper
            lower_change = signals.bounds_lower - signals.bounds_prior_lower

            if upper_change > 0.5 and lower_change > 0.5:
                signals.bounds_direction = "SHIFTED_UP"
                signals.bounds_implication = "Market expecting higher prices"
            elif upper_change < -0.5 and lower_change < -0.5:
                signals.bounds_direction = "SHIFTED_DOWN"
                signals.bounds_implication = "Market expecting lower prices"
            elif abs(upper_change) < 0.5 and abs(lower_change) < 0.5:
                signals.bounds_direction = "STABLE"
                signals.bounds_implication = "Range expectations unchanged"
            else:
                signals.bounds_direction = "MIXED"
                signals.bounds_implication = "Asymmetric expectations"
        else:
            signals.bounds_direction = "UNKNOWN"
            signals.bounds_implication = "No prior data for comparison"

        # 4. Width
        if signals.width_prior:
            width_change_pct = ((signals.width_current - signals.width_prior) / signals.width_prior) * 100
            if width_change_pct > 5:
                signals.width_direction = "WIDENING"
                signals.width_implication = "Volatility expanding, wider stops needed"
            elif width_change_pct < -5:
                signals.width_direction = "NARROWING"
                signals.width_implication = "Volatility contracting, tighter ranges"
            else:
                signals.width_direction = "STABLE"
                signals.width_implication = "Range width unchanged"
        else:
            signals.width_direction = "UNKNOWN"
            signals.width_implication = "No prior data for comparison"

        # 5. Walls (find call and put walls from strikes)
        if strikes:
            positive_gamma = [s for s in strikes if s.net_gamma > 0]
            negative_gamma = [s for s in strikes if s.net_gamma < 0]

            if positive_gamma:
                call_wall_strike = max(positive_gamma, key=lambda s: s.net_gamma)
                signals.call_wall = call_wall_strike.strike

            if negative_gamma:
                put_wall_strike = min(negative_gamma, key=lambda s: s.net_gamma)
                signals.put_wall = put_wall_strike.strike

            if signals.call_wall and signals.put_wall:
                call_dist = abs(spot_price - signals.call_wall)
                put_dist = abs(spot_price - signals.put_wall)
                signals.walls_asymmetry = (call_dist - put_dist) / spot_price * 100

                if signals.walls_asymmetry > 0.3:
                    signals.walls_implication = "Put wall closer - bearish risk profile"
                elif signals.walls_asymmetry < -0.3:
                    signals.walls_implication = "Call wall closer - bullish risk profile"
                else:
                    signals.walls_implication = "Balanced wall distances"

        # 6. Flip point (where net gamma crosses zero)
        flip_point = None
        for i, s in enumerate(sorted(strikes, key=lambda x: x.strike)):
            if i > 0:
                prev_s = sorted(strikes, key=lambda x: x.strike)[i-1]
                if (s.net_gamma > 0 and prev_s.net_gamma < 0) or \
                   (s.net_gamma < 0 and prev_s.net_gamma > 0):
                    flip_point = (s.strike + prev_s.strike) / 2
                    break

        signals.flip_point_current = flip_point
        signals.flip_point_prior = prior_data.get('flip_point')

        if flip_point and signals.flip_point_prior:
            change = flip_point - signals.flip_point_prior
            if change > 2:
                signals.flip_point_direction = "RISING"
                signals.flip_point_implication = "Dealers repositioning higher"
            elif change < -2:
                signals.flip_point_direction = "FALLING"
                signals.flip_point_implication = "Dealers repositioning lower"
            else:
                signals.flip_point_direction = "STABLE"
                signals.flip_point_implication = "Dealer positioning unchanged"
        else:
            signals.flip_point_direction = "UNKNOWN"
            signals.flip_point_implication = "Unable to determine flip point trend"

        # 7. Intraday EM
        signals.intraday_current_em = expected_move
        signals.intraday_open_em = prior_data.get('open_em')

        if signals.intraday_open_em:
            em_change_pct = ((expected_move - signals.intraday_open_em) / signals.intraday_open_em) * 100
            if em_change_pct > 3:
                signals.intraday_direction = "EXPANDING"
                signals.intraday_implication = "Intraday vol increasing"
            elif em_change_pct < -3:
                signals.intraday_direction = "CONTRACTING"
                signals.intraday_implication = "Intraday vol decreasing"
            else:
                signals.intraday_direction = "STABLE"
                signals.intraday_implication = "Intraday vol unchanged"
        else:
            signals.intraday_direction = "UNKNOWN"
            signals.intraday_implication = "No open EM for comparison"

        # 8. GEX Momentum
        signals.gex_current = total_net_gamma
        signals.gex_prior = prior_data.get('total_net_gamma')

        if signals.gex_prior:
            gex_change_pct = ((total_net_gamma - signals.gex_prior) / abs(signals.gex_prior)) * 100 if signals.gex_prior != 0 else 0

            if gex_change_pct > 20:
                signals.gex_direction = "STRONG_BULLISH"
                signals.gex_conviction = "HIGH"
            elif gex_change_pct > 5:
                signals.gex_direction = "BULLISH"
                signals.gex_conviction = "MEDIUM"
            elif gex_change_pct < -20:
                signals.gex_direction = "STRONG_BEARISH"
                signals.gex_conviction = "HIGH"
            elif gex_change_pct < -5:
                signals.gex_direction = "BEARISH"
                signals.gex_conviction = "MEDIUM"
            else:
                signals.gex_direction = "FADING"
                signals.gex_conviction = "LOW"

            signals.gex_implication = f"GEX {signals.gex_direction.lower()} with {signals.gex_conviction.lower()} conviction"
        else:
            signals.gex_direction = "UNKNOWN"
            signals.gex_conviction = "UNKNOWN"
            signals.gex_implication = "No prior GEX for comparison"

        # 9. Wall Break Risk
        if signals.call_wall and signals.put_wall:
            call_dist_pct = abs(spot_price - signals.call_wall) / spot_price * 100
            put_dist_pct = abs(spot_price - signals.put_wall) / spot_price * 100

            # Call wall risk
            if call_dist_pct < 0.3:
                signals.call_wall_risk = "HIGH"
            elif call_dist_pct < 0.7:
                signals.call_wall_risk = "ELEVATED"
            elif call_dist_pct < 1.0:
                signals.call_wall_risk = "MODERATE"
            else:
                signals.call_wall_risk = "LOW"

            # Put wall risk
            if put_dist_pct < 0.3:
                signals.put_wall_risk = "HIGH"
            elif put_dist_pct < 0.7:
                signals.put_wall_risk = "ELEVATED"
            elif put_dist_pct < 1.0:
                signals.put_wall_risk = "MODERATE"
            else:
                signals.put_wall_risk = "LOW"

            if signals.call_wall_risk == "HIGH" or signals.put_wall_risk == "HIGH":
                wall_type = "call" if signals.call_wall_risk == "HIGH" else "put"
                signals.wall_break_implication = f"WARNING: {wall_type.upper()} wall break imminent!"
            else:
                signals.wall_break_implication = "Wall break risk manageable"

        # 10. Combined Signal
        signals.combined_warnings = []

        # Determine combined signal based on multiple factors
        if signals.flip_point_direction == "RISING" and signals.bounds_direction == "SHIFTED_UP":
            if signals.gamma_regime == "NEGATIVE":
                signals.combined_signal = "BULLISH_BREAKOUT"
                signals.combined_confidence = "HIGH"
            else:
                signals.combined_signal = "BULLISH_GRIND"
                signals.combined_confidence = "MEDIUM"
            signals.combined_bias = "BULLISH"
            signals.combined_strategy = "Long calls or call spreads"

        elif signals.flip_point_direction == "FALLING" and signals.bounds_direction == "SHIFTED_DOWN":
            if signals.gamma_regime == "NEGATIVE":
                signals.combined_signal = "BEARISH_BREAKOUT"
                signals.combined_confidence = "HIGH"
            else:
                signals.combined_signal = "BEARISH_GRIND"
                signals.combined_confidence = "MEDIUM"
            signals.combined_bias = "BEARISH"
            signals.combined_strategy = "Long puts or put spreads"

        elif signals.bounds_direction == "STABLE" and signals.width_direction == "NARROWING":
            if signals.gamma_regime == "POSITIVE":
                signals.combined_signal = "SELL_PREMIUM"
                signals.combined_confidence = "HIGH"
            else:
                signals.combined_signal = "SELL_PREMIUM_CAUTION"
                signals.combined_confidence = "LOW"
            signals.combined_bias = "NEUTRAL"
            signals.combined_strategy = "Iron Condor or Credit Spread"

        elif signals.width_direction == "WIDENING":
            signals.combined_signal = "VOL_EXPANSION"
            signals.combined_bias = "NEUTRAL"
            signals.combined_confidence = "MEDIUM"
            signals.combined_strategy = "Wait for direction or use straddles"

        else:
            signals.combined_signal = "MIXED"
            signals.combined_bias = "NEUTRAL"
            signals.combined_confidence = "LOW"
            signals.combined_strategy = "Reduce size, wait for clarity"

        # Add warnings
        if signals.call_wall_risk == "HIGH":
            signals.combined_warnings.append("CALL_WALL_BREAK_IMMINENT")
            signals.combined_signal = "CALL_WALL_BREAK_IMMINENT"
        if signals.put_wall_risk == "HIGH":
            signals.combined_warnings.append("PUT_WALL_BREAK_IMMINENT")
            signals.combined_signal = "PUT_WALL_BREAK_IMMINENT"
        if signals.vix_regime in ["HIGH", "EXTREME"]:
            signals.combined_warnings.append(f"VIX_{signals.vix_regime}")

        return signals

    # ==================== Alert Generation ====================

    def generate_alerts(self, symbol: str, spot_price: float,
                        current_regime: str, previous_regime: Optional[str],
                        gamma_flips: List[Dict], danger_zones: List[Dict],
                        likely_pin: float, current_magnets: List[Dict],
                        previous_magnets: List[float] = None) -> List[Alert]:
        """
        Generate alerts based on current conditions.

        Returns:
            List of Alert objects
        """
        alerts = []
        previous_magnets = previous_magnets or []

        # 1. Gamma Flip alerts
        for flip in gamma_flips:
            alert = Alert(
                alert_type=AlertType.GAMMA_FLIP.value,
                strike=flip['strike'],
                message=f"Strike {flip['strike']} gamma flipped {flip['direction']}",
                priority=AlertPriority.HIGH.value,
                spot_price=spot_price,
                symbol=symbol,
                old_value=str(flip.get('gamma_before', 'N/A')),
                new_value=str(flip.get('gamma_after', 'N/A'))
            )
            alerts.append(alert)

        # 2. Regime Change alert
        if previous_regime and current_regime != previous_regime:
            alert = Alert(
                alert_type=AlertType.REGIME_CHANGE.value,
                strike=None,
                message=f"Gamma regime shifted from {previous_regime} to {current_regime}",
                priority=AlertPriority.HIGH.value,
                spot_price=spot_price,
                symbol=symbol,
                old_value=previous_regime,
                new_value=current_regime
            )
            alerts.append(alert)

        # 3. Magnet Shift alert
        if current_magnets and previous_magnets:
            current_top = current_magnets[0]['strike'] if current_magnets else None
            previous_top = previous_magnets[0] if previous_magnets else None

            if current_top and previous_top and current_top != previous_top:
                alert = Alert(
                    alert_type=AlertType.MAGNET_SHIFT.value,
                    strike=current_top,
                    message=f"Top magnet shifted from {previous_top} to {current_top}",
                    priority=AlertPriority.HIGH.value,
                    spot_price=spot_price,
                    symbol=symbol,
                    old_value=str(previous_top),
                    new_value=str(current_top)
                )
                alerts.append(alert)

        # 4. Danger Zone alerts
        for dz in danger_zones:
            alert = Alert(
                alert_type=AlertType.DANGER_ZONE.value,
                strike=dz['strike'],
                message=f"Strike {dz['strike']} entered {dz['danger_type']} zone (ROC: {dz['roc_5min']:.1f}%)",
                priority=AlertPriority.MEDIUM.value,
                spot_price=spot_price,
                symbol=symbol,
                new_value=dz['danger_type']
            )
            alerts.append(alert)

        # 5. Pin Zone Entry alert
        if likely_pin:
            distance_to_pin = abs(spot_price - likely_pin)
            pin_zone_threshold = spot_price * (self.PIN_ZONE_PROXIMITY_PCT / 100)

            if distance_to_pin <= pin_zone_threshold:
                alert = Alert(
                    alert_type=AlertType.PIN_ZONE_ENTRY.value,
                    strike=likely_pin,
                    message=f"{symbol} entered pin zone near {likely_pin} strike",
                    priority=AlertPriority.MEDIUM.value,
                    spot_price=spot_price,
                    symbol=symbol
                )
                alerts.append(alert)

        return alerts


# Singleton instance
_shared_engine: Optional[SharedGammaEngine] = None


def get_shared_gamma_engine() -> SharedGammaEngine:
    """Get or create singleton shared engine instance"""
    global _shared_engine
    if _shared_engine is None:
        _shared_engine = SharedGammaEngine()
    return _shared_engine
