"""
ARGUS Engine - 0DTE Gamma Live Analysis
=========================================

Named after Argus Panoptes, the "all-seeing" giant with 100 eyes from Greek mythology.
Real-time visualization of net gamma by strike with ML-powered probability predictions.

Features:
- Net gamma calculation per strike
- Gamma flip detection (positive ↔ negative)
- Hybrid probability calculation (ML + gamma-weighted distance)
- Rate of change indicators (1-min and 5-min)
- Magnet, pin, and danger zone detection

Author: AlphaGEX Team
"""

import os
import sys
import logging
from datetime import datetime, timedelta, date
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field, asdict
from enum import Enum
import math
import json

import numpy as np
import pandas as pd

# Add parent directory for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from dotenv import load_dotenv
load_dotenv()

logger = logging.getLogger(__name__)


class GammaRegime(Enum):
    """Overall gamma regime classification"""
    POSITIVE = "POSITIVE"
    NEGATIVE = "NEGATIVE"
    NEUTRAL = "NEUTRAL"


class FlipDirection(Enum):
    """Direction of gamma flip"""
    POS_TO_NEG = "POS_TO_NEG"
    NEG_TO_POS = "NEG_TO_POS"


class DangerType(Enum):
    """Type of danger zone"""
    BUILDING = "BUILDING"      # Gamma accumulating rapidly (>+25% in 5 min)
    COLLAPSING = "COLLAPSING"  # Gamma evaporating (<-25% in 5 min)
    SPIKE = "SPIKE"            # Sudden gamma surge (>+15% in 1 min)


class AlertType(Enum):
    """Types of alerts"""
    GAMMA_FLIP = "GAMMA_FLIP"
    REGIME_CHANGE = "REGIME_CHANGE"
    GAMMA_SPIKE = "GAMMA_SPIKE"
    MAGNET_SHIFT = "MAGNET_SHIFT"
    PIN_ZONE_ENTRY = "PIN_ZONE_ENTRY"
    DANGER_ZONE = "DANGER_ZONE"
    GAMMA_COLLAPSE = "GAMMA_COLLAPSE"
    PATTERN_MATCH = "PATTERN_MATCH"


class AlertPriority(Enum):
    """Alert priority levels"""
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"


@dataclass
class StrikeData:
    """Data for a single strike"""
    strike: float
    net_gamma: float
    call_gamma: float = 0.0
    put_gamma: float = 0.0
    probability: float = 0.0
    gamma_change_pct: float = 0.0
    roc_1min: float = 0.0
    roc_5min: float = 0.0
    roc_30min: float = 0.0
    roc_1hr: float = 0.0
    roc_4hr: float = 0.0
    roc_trading_day: float = 0.0  # ROC since market open (8:30 AM CT)
    volume: int = 0
    call_iv: float = 0.0
    put_iv: float = 0.0
    is_magnet: bool = False
    magnet_rank: Optional[int] = None
    is_pin: bool = False
    is_danger: bool = False
    danger_type: Optional[str] = None
    gamma_flipped: bool = False
    flip_direction: Optional[str] = None
    previous_net_gamma: float = 0.0

    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class GammaSnapshot:
    """Complete gamma snapshot at a point in time"""
    symbol: str
    expiration_date: str
    snapshot_time: datetime
    spot_price: float
    expected_move: float
    vix: float
    total_net_gamma: float
    gamma_regime: str
    previous_regime: Optional[str]
    regime_flipped: bool
    market_status: str
    strikes: List[StrikeData]
    magnets: List[Dict]
    likely_pin: float
    pin_probability: float
    danger_zones: List[Dict]
    gamma_flips: List[Dict]
    pinning_status: Dict = field(default_factory=lambda: {'is_pinning': False})

    def to_dict(self) -> Dict:
        return {
            'symbol': self.symbol,
            'expiration_date': self.expiration_date,
            'snapshot_time': self.snapshot_time.isoformat(),
            'spot_price': self.spot_price,
            'expected_move': self.expected_move,
            'vix': self.vix,
            'total_net_gamma': self.total_net_gamma,
            'gamma_regime': self.gamma_regime,
            'previous_regime': self.previous_regime,
            'regime_flipped': self.regime_flipped,
            'market_status': self.market_status,
            'strikes': [s.to_dict() for s in self.strikes],
            'magnets': self.magnets,
            'likely_pin': self.likely_pin,
            'pin_probability': self.pin_probability,
            'danger_zones': self.danger_zones,
            'gamma_flips': self.gamma_flips,
            'pinning_status': self.pinning_status
        }


@dataclass
class Alert:
    """Alert generated by the system"""
    alert_type: str
    strike: Optional[float]
    message: str
    priority: str
    spot_price: float
    old_value: Optional[str] = None
    new_value: Optional[str] = None
    triggered_at: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> Dict:
        return {
            'alert_type': self.alert_type,
            'strike': self.strike,
            'message': self.message,
            'priority': self.priority,
            'spot_price': self.spot_price,
            'old_value': self.old_value,
            'new_value': self.new_value,
            'triggered_at': self.triggered_at.isoformat()
        }


class ArgusEngine:
    """
    Core engine for ARGUS 0DTE Gamma Live analysis.

    Responsibilities:
    - Fetch and process gamma data from Tradier
    - Calculate net gamma per strike
    - Detect gamma flips (positive ↔ negative)
    - Calculate probabilities using hybrid approach
    - Identify magnets, pins, and danger zones
    - Generate alerts for significant events
    """

    # Thresholds - keep high to only show REAL spikes
    ROC_1MIN_SPIKE_THRESHOLD = 15.0  # % for SPIKE danger type
    ROC_5MIN_BUILDING_THRESHOLD = 25.0  # % for BUILDING danger type
    ROC_5MIN_COLLAPSING_THRESHOLD = -25.0  # % for COLLAPSING danger type
    PIN_ZONE_PROXIMITY_PCT = 0.5  # % distance from likely pin
    GAMMA_SPIKE_THRESHOLD = 50.0  # % increase in 5 min for alert
    GAMMA_COLLAPSE_THRESHOLD = -20.0  # % decrease in 10 min for alert

    def __init__(self):
        """Initialize the ARGUS engine"""
        self.previous_snapshot: Optional[GammaSnapshot] = None
        self.history: Dict[float, List[Tuple[datetime, float]]] = {}  # strike -> [(time, gamma)]
        self.previous_magnets: List[float] = []
        self.alerts: List[Alert] = []

        # Import ML models lazily to avoid circular imports
        self._ml_models = None

        # Expected move smoothing state
        # EMA smoothing reduces chart structure volatility by ~70-80%
        self._previous_expected_move: Optional[float] = None
        self._ema_alpha: float = 0.3  # 30% new value, 70% previous (tunable)

        # Gamma smoothing state - reduces noise from Tradier Greeks recalculations
        # Rolling window stores recent gamma values per strike for median smoothing
        self._gamma_window: Dict[float, List[float]] = {}  # strike -> [recent gamma values]
        self._gamma_window_size: int = 5  # Number of readings to average
        self._gamma_smoothing_enabled: bool = True
        self._previous_spot_price: Optional[float] = None
        self._max_gamma_change_pct: float = 50.0  # Max % change allowed without price move

        # Market open baseline - stores first 5 minutes of readings for stable baseline
        self._market_open_baselines: Dict[float, List[float]] = {}  # strike -> [opening values]
        self._baseline_locked: bool = False  # Lock baseline after 5 minutes

        # Locked GEX levels at market open (like SpotGamma does for 0DTE)
        # OI doesn't change intraday, so GEX rankings should be stable
        self._locked_gex_rankings: Dict[float, int] = {}  # strike -> rank at open
        self._locked_gex_values: Dict[float, float] = {}  # strike -> GEX value at open
        self._gex_levels_locked: bool = False
        self._major_strikes_at_open: List[float] = []  # Top 5 strikes by GEX at open

    def reset_expected_move_smoothing(self):
        """
        Reset the expected move smoothing state.

        Call this at the start of a new trading day or when you want
        the expected move to immediately reflect current option prices
        without smoothing from previous values.
        """
        self._previous_expected_move = None
        logger.debug("Expected move smoothing state reset")

    def set_ema_alpha(self, alpha: float):
        """
        Set the EMA smoothing factor for expected move.

        Args:
            alpha: Value between 0 and 1. Higher = more responsive to changes,
                   lower = more stable/smooth. Default is 0.3.
                   - 0.1 = very smooth (90% previous, 10% new)
                   - 0.3 = balanced (70% previous, 30% new) [default]
                   - 0.5 = responsive (50% previous, 50% new)
        """
        if not 0 < alpha <= 1:
            raise ValueError("Alpha must be between 0 (exclusive) and 1 (inclusive)")
        self._ema_alpha = alpha
        logger.info(f"Expected move EMA alpha set to {alpha}")

    def set_gamma_smoothing(self, enabled: bool = True, window_size: int = 5,
                            max_change_pct: float = 50.0):
        """
        Configure gamma smoothing to reduce noise from Tradier Greeks recalculations.

        Args:
            enabled: Whether to enable gamma smoothing (default True)
            window_size: Number of recent readings to use for median (default 5)
            max_change_pct: Maximum % change allowed in single reading without price move (default 50%)
        """
        self._gamma_smoothing_enabled = enabled
        self._gamma_window_size = window_size
        self._max_gamma_change_pct = max_change_pct
        logger.info(f"Gamma smoothing: enabled={enabled}, window={window_size}, max_change={max_change_pct}%")

    def reset_gamma_smoothing(self):
        """
        Reset gamma smoothing state at start of new trading day.
        Call this when market opens to clear stale data.
        """
        self._gamma_window = {}
        self._previous_spot_price = None
        self._market_open_baselines = {}
        self._baseline_locked = False
        # Reset locked GEX levels for new trading day
        self._locked_gex_rankings = {}
        self._locked_gex_values = {}
        self._gex_levels_locked = False
        self._major_strikes_at_open = []
        logger.debug("Gamma smoothing state reset for new trading day")

    def lock_gex_levels_at_open(self, strikes_data: List, spot_price: float):
        """
        Lock GEX levels at market open (like SpotGamma does for 0DTE).

        Since OI doesn't change intraday, the relative GEX rankings should be stable.
        This prevents noisy gamma recalculations from changing which strikes are "major".

        Args:
            strikes_data: List of StrikeData objects with net_gamma populated
            spot_price: Current spot price
        """
        if self._gex_levels_locked:
            return  # Already locked

        from zoneinfo import ZoneInfo
        CENTRAL_TZ = ZoneInfo("America/Chicago")
        now = datetime.now(CENTRAL_TZ)
        market_open = now.replace(hour=8, minute=30, second=0, microsecond=0)

        # Only lock after market open and within first 10 minutes
        if now < market_open:
            return
        if (now - market_open).total_seconds() > 600:  # 10 minute window to lock
            if not self._gex_levels_locked and self._locked_gex_values:
                self._gex_levels_locked = True
                logger.info(f"GEX levels locked with {len(self._locked_gex_values)} strikes")
            return

        # Calculate GEX for each strike and store
        for strike_data in strikes_data:
            strike = strike_data.strike
            gex = abs(strike_data.net_gamma)  # Already OI-weighted from calculate_net_gamma
            self._locked_gex_values[strike] = gex

        # Rank strikes by GEX (highest = rank 1)
        sorted_strikes = sorted(self._locked_gex_values.items(), key=lambda x: abs(x[1]), reverse=True)
        for rank, (strike, _) in enumerate(sorted_strikes, 1):
            self._locked_gex_rankings[strike] = rank

        # Store top 5 as "major strikes" - these should remain major all day
        self._major_strikes_at_open = [strike for strike, _ in sorted_strikes[:5]]
        logger.debug(f"GEX levels captured: top 5 = {self._major_strikes_at_open}")

    def get_locked_gex_rank(self, strike: float) -> Optional[int]:
        """Get the locked GEX rank for a strike (set at market open)."""
        return self._locked_gex_rankings.get(strike)

    def is_major_strike(self, strike: float) -> bool:
        """Check if strike was in top 5 GEX at market open."""
        return strike in self._major_strikes_at_open

    def get_gex_rank_change(self, strike: float, current_rank: int) -> int:
        """
        Get how much a strike's GEX rank has changed since market open.

        Returns:
            Positive = improved (moved up in ranking)
            Negative = declined (moved down in ranking)
            0 = no change or no baseline
        """
        locked_rank = self._locked_gex_rankings.get(strike)
        if locked_rank is None:
            return 0
        # Lower rank number = higher importance, so improvement = negative change
        return locked_rank - current_rank

    def _smooth_gamma_value(self, strike: float, raw_gamma: float, spot_price: float) -> float:
        """
        Apply smoothing to a raw gamma value to reduce noise.

        Uses median of recent readings (robust to outliers) and validates
        that large changes only occur when price has moved significantly.

        Args:
            strike: Strike price
            raw_gamma: Raw gamma value from Tradier
            spot_price: Current spot price

        Returns:
            Smoothed gamma value
        """
        if not self._gamma_smoothing_enabled:
            return raw_gamma

        # Initialize window for this strike if needed
        if strike not in self._gamma_window:
            self._gamma_window[strike] = []

        window = self._gamma_window[strike]

        # Check for suspicious large change without price movement
        if window and self._previous_spot_price is not None:
            last_gamma = window[-1]
            if last_gamma != 0:
                change_pct = abs((raw_gamma - last_gamma) / abs(last_gamma)) * 100
                price_change_pct = abs((spot_price - self._previous_spot_price) / self._previous_spot_price) * 100

                # If gamma changed dramatically but price didn't, dampen the change
                if change_pct > self._max_gamma_change_pct and price_change_pct < 0.1:
                    # Blend: 70% previous, 30% new (dampen noise)
                    raw_gamma = 0.7 * last_gamma + 0.3 * raw_gamma
                    logger.debug(f"Dampened gamma spike at strike {strike}: "
                                f"{change_pct:.1f}% change with {price_change_pct:.2f}% price move")

        # Add to rolling window
        window.append(raw_gamma)

        # Keep window at configured size
        if len(window) > self._gamma_window_size:
            window.pop(0)

        # Use median for robustness to outliers
        if len(window) >= 3:
            smoothed = float(np.median(window))
        else:
            # Not enough data yet, use simple average
            smoothed = sum(window) / len(window)

        return smoothed

    def _update_market_open_baseline(self, strike: float, gamma: float):
        """
        Update market open baseline for a strike.

        Collects readings for first 5 minutes after market open to establish
        a stable baseline (average of multiple readings, not just first snapshot).
        """
        from zoneinfo import ZoneInfo
        CENTRAL_TZ = ZoneInfo("America/Chicago")
        now = datetime.now(CENTRAL_TZ)
        market_open = now.replace(hour=8, minute=30, second=0, microsecond=0)

        # Only collect baseline in first 5 minutes after open
        if now < market_open or (now - market_open).total_seconds() > 300:
            if not self._baseline_locked and self._market_open_baselines:
                self._baseline_locked = True
                logger.info("Market open baselines locked after 5 minutes")
            return

        # Add to baseline collection
        if strike not in self._market_open_baselines:
            self._market_open_baselines[strike] = []

        self._market_open_baselines[strike].append(gamma)

    def get_market_open_baseline(self, strike: float) -> Optional[float]:
        """
        Get the stable market open baseline for a strike.

        Returns median of first 5 minutes of readings for stability.
        """
        if strike not in self._market_open_baselines:
            return None

        baselines = self._market_open_baselines[strike]
        if not baselines:
            return None

        # Use median for robustness
        return float(np.median(baselines))

    def _get_ml_models(self):
        """Lazy load ML probability models"""
        if self._ml_models is None:
            try:
                from quant.gex_probability_models import GEXProbabilityModels
                self._ml_models = GEXProbabilityModels()
                logger.info("Loaded GEX probability models for ARGUS")
            except Exception as e:
                logger.warning(f"Could not load ML models: {e}")
                self._ml_models = False
        return self._ml_models if self._ml_models else None

    def get_market_status(self) -> str:
        """Determine current market status based on time, including holidays"""
        from zoneinfo import ZoneInfo
        CENTRAL_TZ = ZoneInfo("America/Chicago")
        now = datetime.now(CENTRAL_TZ)
        hour = now.hour
        minute = now.minute

        # Weekend check
        if now.weekday() >= 5:
            return 'closed'

        # Holiday check - use MarketCalendar holidays
        from trading.market_calendar import MARKET_HOLIDAYS_2024_2025
        date_str = now.strftime('%Y-%m-%d')
        if date_str in MARKET_HOLIDAYS_2024_2025:
            return 'holiday'

        time_minutes = hour * 60 + minute

        # Pre-market: 4:00am - 8:30am CT (5:00am - 9:30am ET)
        if 4 * 60 <= time_minutes < 8 * 60 + 30:
            return 'pre_market'
        # Market hours: 8:30am - 3:00pm CT (9:30am - 4:00pm ET)
        elif 8 * 60 + 30 <= time_minutes < 15 * 60:
            return 'open'
        # After hours: 3:00pm - 7:00pm CT (4:00pm - 8:00pm ET)
        elif 15 * 60 <= time_minutes < 19 * 60:
            return 'after_hours'
        else:
            return 'closed'

    def get_0dte_expiration(self, target_day: str = 'today') -> str:
        """
        Get the 0DTE expiration date.
        SPY has 0DTE every day (Mon-Fri).

        Args:
            target_day: 'today', 'mon', 'tue', 'wed', 'thu', 'fri'

        Returns:
            Expiration date string in YYYY-MM-DD format
        """
        today = date.today()

        if target_day == 'today':
            # If weekend, return next Monday
            if today.weekday() >= 5:
                days_until_monday = 7 - today.weekday()
                return (today + timedelta(days=days_until_monday)).strftime('%Y-%m-%d')
            return today.strftime('%Y-%m-%d')

        # Map day names to weekday numbers
        day_map = {'mon': 0, 'tue': 1, 'wed': 2, 'thu': 3, 'fri': 4}
        target_weekday = day_map.get(target_day.lower(), today.weekday())

        # Calculate days until target
        days_ahead = target_weekday - today.weekday()
        if days_ahead < 0:
            days_ahead += 7

        target_date = today + timedelta(days=days_ahead)
        return target_date.strftime('%Y-%m-%d')

    def calculate_expected_move(self, atm_call_price: float, atm_put_price: float,
                                  apply_smoothing: bool = True) -> float:
        """
        Calculate expected move from ATM straddle price with optional EMA smoothing.

        Smoothing reduces chart structure volatility by dampening rapid changes
        in expected move that cause strike filtering bounds to shift frequently.

        Args:
            atm_call_price: Price of ATM call
            atm_put_price: Price of ATM put
            apply_smoothing: Whether to apply EMA smoothing (default True)

        Returns:
            Expected move in dollars (smoothed if enabled)
        """
        raw_em = atm_call_price + atm_put_price

        if not apply_smoothing or raw_em <= 0:
            return raw_em

        # Apply exponential moving average smoothing
        if self._previous_expected_move is None:
            # First calculation - use raw value
            smoothed_em = raw_em
        else:
            # EMA: smoothed = alpha * new + (1 - alpha) * previous
            smoothed_em = (self._ema_alpha * raw_em +
                          (1 - self._ema_alpha) * self._previous_expected_move)

        # Update state for next calculation
        self._previous_expected_move = smoothed_em

        return smoothed_em

    def calculate_net_gamma(self, call_gamma: float, put_gamma: float,
                            call_oi: int = 0, put_oi: int = 0) -> float:
        """
        Calculate net gamma at a strike.

        Net gamma = call_gamma * call_OI * 100 + put_gamma * put_OI * 100
        (Both should be positive as they measure absolute exposure)

        For visualization, we show the sum as net gamma affects dealer hedging.
        """
        # Gamma is always positive, but we multiply by OI and contract multiplier
        call_exposure = abs(call_gamma) * call_oi * 100 if call_oi else abs(call_gamma)
        put_exposure = abs(put_gamma) * put_oi * 100 if put_oi else abs(put_gamma)

        # Net gamma is typically calls - puts for directional bias
        # Positive = calls dominate (dealers hedging by buying)
        # Negative = puts dominate (dealers hedging by selling)
        return call_exposure - put_exposure

    def detect_gamma_flip(self, current_gamma: float, previous_gamma: float) -> Tuple[bool, Optional[str]]:
        """
        Detect if gamma flipped from positive to negative or vice versa.

        Returns:
            Tuple of (flipped: bool, direction: Optional[str])
        """
        if previous_gamma is None or previous_gamma == 0:
            return False, None

        # Check for sign change
        if current_gamma > 0 and previous_gamma < 0:
            return True, FlipDirection.NEG_TO_POS.value
        elif current_gamma < 0 and previous_gamma > 0:
            return True, FlipDirection.POS_TO_NEG.value

        return False, None

    def classify_gamma_regime(self, total_net_gamma: float) -> str:
        """
        Classify overall gamma regime based on total net gamma.

        Returns:
            POSITIVE, NEGATIVE, or NEUTRAL
        """
        # Threshold for neutral zone (can be tuned)
        neutral_threshold = 1e9  # $1B

        if total_net_gamma > neutral_threshold:
            return GammaRegime.POSITIVE.value
        elif total_net_gamma < -neutral_threshold:
            return GammaRegime.NEGATIVE.value
        else:
            return GammaRegime.NEUTRAL.value

    def get_ml_status(self) -> Dict:
        """Get ML model status for monitoring"""
        ml_models = self._get_ml_models()
        if not ml_models:
            return {
                'is_trained': False,
                'model_info': None,
                'needs_retraining': True,
                'staleness_hours': None,
                'status': 'NOT_LOADED'
            }

        return {
            'is_trained': ml_models.is_trained,
            'model_info': ml_models.model_info,
            'needs_retraining': ml_models.needs_retraining() if hasattr(ml_models, 'needs_retraining') else True,
            'staleness_hours': ml_models.get_model_staleness_hours() if hasattr(ml_models, 'get_model_staleness_hours') else None,
            'status': 'TRAINED' if ml_models.is_trained else 'NOT_TRAINED'
        }

    def calculate_probability_hybrid(self, strike: float, spot_price: float,
                                     net_gamma: float, total_gamma: float,
                                     expected_move: float,
                                     gamma_structure: Dict = None) -> float:
        """
        Calculate probability of price landing at a strike using hybrid approach.

        60% ML model + 40% gamma-weighted distance

        Args:
            strike: Strike price
            spot_price: Current spot price
            net_gamma: Net gamma at this strike
            total_gamma: Total absolute gamma across all strikes
            expected_move: Expected move in dollars
            gamma_structure: Optional structure for ML model

        Returns:
            Probability as percentage (0-100)
        """
        # Distance component (40% weight)
        distance_from_spot = abs(strike - spot_price)
        gamma_magnitude = abs(net_gamma)

        # Avoid division by zero
        if total_gamma == 0:
            total_gamma = 1

        # Gamma weight (higher gamma = more likely to attract)
        gamma_weight = gamma_magnitude / total_gamma

        # Distance decay (exponential decay based on expected move)
        if expected_move > 0:
            distance_decay = math.exp(-distance_from_spot / expected_move)
        else:
            distance_decay = 1.0 if distance_from_spot == 0 else 0.0

        distance_probability = gamma_weight * distance_decay * 100

        # ML component (60% weight) - try to use ML models
        ml_probability = distance_probability  # Default to distance if no ML
        ml_used = False

        ml_models = self._get_ml_models()
        if ml_models and ml_models.is_trained:
            # Build minimal gamma_structure if not provided
            if gamma_structure is None:
                gamma_structure = {
                    'net_gamma': net_gamma,
                    'total_gamma': total_gamma,
                    'flip_point': spot_price,
                    'magnets': [{'strike': strike, 'gamma': net_gamma}],
                    'vix': 20,
                    'gamma_regime': 'POSITIVE' if net_gamma > 0 else 'NEGATIVE',
                    'expected_move': expected_move
                }

            try:
                ml_result = ml_models.predict_magnet_attraction(
                    strike, spot_price, gamma_structure
                )
                if ml_result and 'probability' in ml_result:
                    ml_probability = ml_result['probability'] * 100
                    ml_used = True
            except Exception as e:
                logger.debug(f"ML prediction failed, using distance only: {e}")

        # Combined probability
        combined = (0.6 * ml_probability) + (0.4 * distance_probability)

        # Log ML usage periodically
        if not hasattr(self, '_ml_call_count'):
            self._ml_call_count = 0
        self._ml_call_count += 1
        if self._ml_call_count % 500 == 0:
            logger.info(f"ARGUS ML probability: used={ml_used}, calls={self._ml_call_count}")

        return combined

    def calculate_roc(self, strike: float, current_gamma: float,
                      history: List[Tuple[datetime, float]],
                      minutes: int = 1) -> float:
        """
        Calculate rate of change for a strike over specified minutes.

        Args:
            strike: Strike price
            current_gamma: Current gamma value
            history: List of (timestamp, gamma) tuples
            minutes: Number of minutes to look back (1, 5, 30, 60, 240)

        Returns:
            Rate of change as percentage
        """
        if not history or len(history) < 2:
            return 0.0

        from zoneinfo import ZoneInfo
        CENTRAL_TZ = ZoneInfo("America/Chicago")

        # Find value from X minutes ago - use timezone-aware datetime
        target_time = datetime.now(CENTRAL_TZ) - timedelta(minutes=minutes)
        old_gamma = None

        for timestamp, gamma in reversed(history):
            # Handle timezone-aware comparison
            if timestamp.tzinfo is None:
                timestamp = timestamp.replace(tzinfo=CENTRAL_TZ)
            if timestamp <= target_time:
                old_gamma = gamma
                break

        if old_gamma is None or old_gamma == 0:
            return 0.0

        roc = ((current_gamma - old_gamma) / abs(old_gamma)) * 100
        return round(roc, 2)

    def calculate_roc_since_open(self, current_gamma: float,
                                  history: List[Tuple[datetime, float]],
                                  strike: float = None) -> float:
        """
        Calculate rate of change since market open (8:30 AM CT).

        Uses stable baseline (median of first 5 minutes) when available,
        falls back to first recorded value otherwise.

        Args:
            current_gamma: Current gamma value
            history: List of (timestamp, gamma) tuples
            strike: Strike price (for baseline lookup)

        Returns:
            Rate of change as percentage since market open
        """
        if not history or len(history) < 1:
            return 0.0

        from zoneinfo import ZoneInfo
        CENTRAL_TZ = ZoneInfo("America/Chicago")
        now = datetime.now(CENTRAL_TZ)

        # Market open is 8:30 AM CT
        market_open = now.replace(hour=8, minute=30, second=0, microsecond=0)

        # If it's before market open today, no trading day ROC available
        if now < market_open:
            return 0.0

        # Try to use stable baseline first (median of first 5 minutes)
        open_gamma = None
        if strike is not None:
            open_gamma = self.get_market_open_baseline(strike)

        # Fall back to first recorded value if no stable baseline
        if open_gamma is None:
            for timestamp, gamma in history:
                # Handle timezone-aware comparison
                if timestamp.tzinfo is None:
                    timestamp = timestamp.replace(tzinfo=CENTRAL_TZ)
                if timestamp >= market_open:
                    open_gamma = gamma
                    break

        if open_gamma is None or open_gamma == 0:
            return 0.0

        roc = ((current_gamma - open_gamma) / abs(open_gamma)) * 100
        return round(roc, 2)

    def update_history(self, strike: float, gamma: float, timestamp: datetime = None):
        """Update gamma history for a strike"""
        from zoneinfo import ZoneInfo
        CENTRAL_TZ = ZoneInfo("America/Chicago")

        if timestamp is None:
            timestamp = datetime.now(CENTRAL_TZ)

        # Ensure timestamp is timezone-aware
        if timestamp.tzinfo is None:
            timestamp = timestamp.replace(tzinfo=CENTRAL_TZ)

        if strike not in self.history:
            self.history[strike] = []

        self.history[strike].append((timestamp, gamma))

        # Keep history for full trading day (7 hours = 420 minutes to cover pre-market to close)
        cutoff = timestamp - timedelta(minutes=420)
        self.history[strike] = [
            (t, g) for t, g in self.history[strike]
            if (t.replace(tzinfo=CENTRAL_TZ) if t.tzinfo is None else t) >= cutoff
        ]

    def identify_magnets(self, strikes: List[StrikeData], top_n: int = 3) -> List[Dict]:
        """
        Identify top N gamma magnets (strikes with highest absolute gamma).

        Returns:
            List of dicts with strike and gamma info
        """
        sorted_strikes = sorted(strikes, key=lambda s: abs(s.net_gamma), reverse=True)

        magnets = []
        for i, strike_data in enumerate(sorted_strikes[:top_n]):
            magnets.append({
                'rank': i + 1,
                'strike': strike_data.strike,
                'net_gamma': strike_data.net_gamma,
                'probability': strike_data.probability
            })
            strike_data.is_magnet = True
            strike_data.magnet_rank = i + 1

        return magnets

    def identify_pin_strike(self, strikes: List[StrikeData], spot_price: float) -> Tuple[float, float]:
        """
        Identify the likely pin strike.

        Pin score = (probability * 0.4) + (gamma_rank * 0.3) + (proximity_score * 0.3)

        Returns:
            Tuple of (pin_strike, pin_probability)
        """
        if not strikes:
            return 0.0, 0.0

        best_pin = None
        best_score = -1

        # Rank strikes by gamma
        sorted_by_gamma = sorted(strikes, key=lambda s: abs(s.net_gamma), reverse=True)
        gamma_ranks = {s.strike: i + 1 for i, s in enumerate(sorted_by_gamma)}

        for strike_data in strikes:
            # Probability component (0-1, higher is better)
            prob_score = strike_data.probability / 100

            # Gamma rank component (1 is best, invert so higher is better)
            gamma_rank = gamma_ranks.get(strike_data.strike, len(strikes))
            gamma_score = 1 - (gamma_rank / len(strikes))

            # Proximity score (closer to spot is better)
            distance = abs(strike_data.strike - spot_price)
            max_distance = max(abs(s.strike - spot_price) for s in strikes) or 1
            proximity_score = 1 - (distance / max_distance)

            # Combined score
            pin_score = (prob_score * 0.4) + (gamma_score * 0.3) + (proximity_score * 0.3)

            if pin_score > best_score:
                best_score = pin_score
                best_pin = strike_data

        if best_pin:
            best_pin.is_pin = True
            return best_pin.strike, best_pin.probability

        return 0.0, 0.0

    def identify_danger_zones(self, strikes: List[StrikeData]) -> List[Dict]:
        """
        Identify danger zones - strikes with rapid gamma changes.

        Thresholds:
        - BUILDING: 5-min ROC > +25%
        - COLLAPSING: 5-min ROC < -25%
        - SPIKE: 1-min ROC > +15%
        """
        danger_zones = []

        for strike_data in strikes:
            danger_type = None

            if strike_data.roc_5min >= self.ROC_5MIN_BUILDING_THRESHOLD:
                danger_type = DangerType.BUILDING.value
            elif strike_data.roc_5min <= self.ROC_5MIN_COLLAPSING_THRESHOLD:
                danger_type = DangerType.COLLAPSING.value
            elif strike_data.roc_1min >= self.ROC_1MIN_SPIKE_THRESHOLD:
                danger_type = DangerType.SPIKE.value

            if danger_type:
                strike_data.is_danger = True
                strike_data.danger_type = danger_type
                danger_zones.append({
                    'strike': strike_data.strike,
                    'danger_type': danger_type,
                    'roc_1min': strike_data.roc_1min,
                    'roc_5min': strike_data.roc_5min
                })

        return danger_zones

    def detect_pinning_condition(
        self,
        strikes: List[StrikeData],
        spot_price: float,
        likely_pin: float,
        danger_zones: List[Dict]
    ) -> Dict:
        """
        Detect if the market is in a "pinning" condition.

        Pinning is detected when:
        1. No danger zones (gamma is stable, no significant ROC)
        2. Spot price is within 0.5% of likely pin strike
        3. Average absolute ROC is low (< 5%)

        Returns:
            Dict with pinning status and details
        """
        if not strikes or not likely_pin:
            return {'is_pinning': False}

        # Check 1: No danger zones
        has_no_danger = len(danger_zones) == 0

        # Check 2: Spot is close to pin (within 0.5%)
        distance_to_pin_pct = abs(spot_price - likely_pin) / spot_price * 100 if spot_price > 0 else 100
        is_near_pin = distance_to_pin_pct < 0.5

        # Check 3: Average ROC is low (stable gamma)
        roc_values = []
        for s in strikes:
            roc_values.extend([abs(s.roc_1min), abs(s.roc_5min)])

        avg_roc = sum(roc_values) / len(roc_values) if roc_values else 0
        is_stable = avg_roc < 5.0  # Less than 5% average movement

        # Determine pinning status
        is_pinning = has_no_danger and (is_near_pin or is_stable)

        if is_pinning:
            if is_near_pin:
                message = f"PINNING: Price is pinning near ${likely_pin} strike (within {distance_to_pin_pct:.2f}%). Gamma stable, expect tight range."
            else:
                message = f"STABLE: No gamma movement detected (avg ROC: {avg_roc:.1f}%). Price likely to gravitate toward ${likely_pin} pin."

            return {
                'is_pinning': True,
                'pin_strike': likely_pin,
                'distance_to_pin_pct': round(distance_to_pin_pct, 2),
                'avg_roc': round(avg_roc, 2),
                'message': message,
                'trade_idea': 'Iron Condor or Credit Spread around pin strike may be favorable.'
            }

        return {'is_pinning': False}

    def generate_trading_signal(self, strikes: List[StrikeData], spot_price: float,
                                 likely_pin: float, gamma_regime: str) -> Dict:
        """
        Generate actionable trading signal based on GEX structure.

        Uses OI-WEIGHTED GEX RANKINGS (stable because OI doesn't change intraday)
        instead of noisy gamma % changes. This follows SpotGamma's methodology
        of locking major levels at market open for 0DTE.

        A strike is "building" if its GEX rank improved 3+ positions since open.
        A strike is "decaying" if its GEX rank declined 3+ positions since open.
        Major strikes (top 5 at open) stay major unless they drop to rank 10+.

        Returns:
            Dict with signal, confidence, and specific trade recommendations
        """
        if not strikes:
            return {
                'signal': 'NO_DATA',
                'confidence': 'LOW',
                'action': 'Wait for market data',
                'explanation': 'Insufficient data to generate signal'
            }

        # First, lock GEX levels at open if not already locked
        self.lock_gex_levels_at_open(strikes, spot_price)

        # Calculate current GEX rankings
        sorted_by_gex = sorted(strikes, key=lambda s: abs(s.net_gamma), reverse=True)
        current_rankings = {s.strike: rank for rank, s in enumerate(sorted_by_gex, 1)}

        # Categorize strikes by GEX RANK change (stable) instead of % change (noisy)
        # Building = rank improved by 3+ positions (strike becoming more important)
        # Decaying = rank declined by 3+ positions (strike losing importance)
        building_strikes = []
        decaying_strikes = []
        stable_strikes = []

        for s in strikes:
            current_rank = current_rankings.get(s.strike, len(strikes))
            rank_change = self.get_gex_rank_change(s.strike, current_rank)

            # Mark major strikes (top 5 at open) - these are stable anchors
            is_major = self.is_major_strike(s.strike)

            if rank_change >= 3:  # Improved 3+ positions
                building_strikes.append(s)
            elif rank_change <= -3:  # Declined 3+ positions
                # Major strikes only "decay" if they drop to rank 10+
                if is_major and current_rank < 10:
                    stable_strikes.append(s)  # Major strike stays stable
                else:
                    decaying_strikes.append(s)
            else:
                stable_strikes.append(s)

        # Separate building above vs below spot
        building_above = [s for s in building_strikes if s.strike > spot_price]
        building_below = [s for s in building_strikes if s.strike < spot_price]
        decaying_above = [s for s in decaying_strikes if s.strike > spot_price]
        decaying_below = [s for s in decaying_strikes if s.strike < spot_price]

        # Count for pattern detection
        n_building_above = len(building_above)
        n_building_below = len(building_below)
        n_decaying_above = len(decaying_above)
        n_decaying_below = len(decaying_below)
        n_building = len(building_strikes)
        n_decaying = len(decaying_strikes)

        # Calculate average building strength
        avg_building_pct = (sum(s.roc_trading_day for s in building_strikes) /
                           n_building if n_building else 0)
        avg_decaying_pct = (sum(s.roc_trading_day for s in decaying_strikes) /
                           n_decaying if n_decaying else 0)

        # Detect patterns and generate signals
        # Include major strikes from open for stability reference
        signal_data = {
            'building_count': n_building,
            'decaying_count': n_decaying,
            'building_above_spot': n_building_above,
            'building_below_spot': n_building_below,
            'avg_building_strength': round(avg_building_pct, 1),
            'avg_decaying_strength': round(avg_decaying_pct, 1),
            'gamma_regime': gamma_regime,
            'major_strikes': self._major_strikes_at_open,  # Top 5 GEX at open (stable anchors)
            'gex_locked': self._gex_levels_locked,
            'methodology': 'GEX_RANK'  # Using OI-weighted rank changes, not noisy % changes
        }

        # PATTERN 1: Symmetric building (premium selling opportunity)
        if n_building_above >= 2 and n_building_below >= 2:
            signal_data.update({
                'signal': 'SELL_PREMIUM',
                'confidence': 'HIGH' if gamma_regime == 'POSITIVE' else 'MEDIUM',
                'action': f'Iron Condor or Iron Butterfly centered at ${likely_pin}',
                'explanation': (f'GEX gaining importance above ({n_building_above} strikes) '
                               f'and below ({n_building_below} strikes) spot. '
                               f'Dealers capping both directions. Range-bound near ${likely_pin}.'),
                'short_strike_call': building_above[0].strike if building_above else None,
                'short_strike_put': building_below[-1].strike if building_below else None,
            })

        # PATTERN 2: Building above only (bullish bias)
        elif n_building_above >= 2 and n_building_below == 0:
            target_strike = building_above[0].strike if building_above else spot_price + 2
            signal_data.update({
                'signal': 'BULLISH_BIAS',
                'confidence': 'HIGH' if gamma_regime == 'NEGATIVE' else 'MEDIUM',
                'action': f'Bull call spread or call debit spread targeting ${target_strike}',
                'explanation': (f'GEX concentrating above spot ({n_building_above} strikes gaining rank). '
                               f'Call wall building = resistance, but dealers must buy on breakout. '
                               f'Target: ${target_strike}'),
                'target_strike': target_strike
            })

        # PATTERN 3: Building below only (bearish bias)
        elif n_building_below >= 2 and n_building_above == 0:
            target_strike = building_below[-1].strike if building_below else spot_price - 2
            signal_data.update({
                'signal': 'BEARISH_BIAS',
                'confidence': 'HIGH' if gamma_regime == 'NEGATIVE' else 'MEDIUM',
                'action': f'Bear put spread or put debit spread targeting ${target_strike}',
                'explanation': (f'GEX concentrating below spot ({n_building_below} strikes gaining rank). '
                               f'Put wall building = support, but dealers must sell on breakdown. '
                               f'Target: ${target_strike}'),
                'target_strike': target_strike
            })

        # PATTERN 4: Widespread decay (momentum/breakout likely)
        elif n_decaying >= 4 and n_building <= 1:
            signal_data.update({
                'signal': 'BREAKOUT_LIKELY',
                'confidence': 'HIGH' if gamma_regime == 'NEGATIVE' else 'MEDIUM',
                'action': 'Long straddle or strangle at ATM strike',
                'explanation': (f'GEX importance declining at {n_decaying} strikes. '
                               f'Dealer hedging walls weakening - less resistance to moves. '
                               f'Expect larger range, direction unclear.')
            })

        # PATTERN 5: Building at pin, decaying elsewhere (strong pinning)
        elif n_building == 1 and abs(building_strikes[0].strike - likely_pin) <= 1:
            signal_data.update({
                'signal': 'STRONG_PIN',
                'confidence': 'HIGH',
                'action': f'Sell premium around ${likely_pin} pin. Tight credit spread or butterfly.',
                'explanation': (f'GEX concentrating at pin strike ${likely_pin}. '
                               f'Major strike holding rank - strong magnet. Tight range expected.')
            })

        # PATTERN 6: No clear pattern but stable
        elif n_building <= 1 and n_decaying <= 1:
            signal_data.update({
                'signal': 'NEUTRAL_WAIT',
                'confidence': 'LOW',
                'action': 'Wait for clearer pattern or trade small iron condor',
                'explanation': 'Gamma structure stable but no strong directional signal. Wait for setup.'
            })

        # PATTERN 7: Mixed/chaotic
        else:
            signal_data.update({
                'signal': 'MIXED_SIGNALS',
                'confidence': 'LOW',
                'action': 'Reduce position size. Consider waiting.',
                'explanation': (f'Mixed gamma signals: {n_building} building, {n_decaying} decaying. '
                               f'Market structure unclear - trade small or sit out.')
            })

        return signal_data

    def generate_alerts(self, current: GammaSnapshot, previous: Optional[GammaSnapshot]) -> List[Alert]:
        """
        Generate alerts based on current snapshot vs previous.
        """
        alerts = []

        # 1. Gamma Flip alerts
        for flip in current.gamma_flips:
            alert = Alert(
                alert_type=AlertType.GAMMA_FLIP.value,
                strike=flip['strike'],
                message=f"Strike {flip['strike']} gamma flipped {flip['direction']}",
                priority=AlertPriority.HIGH.value,
                spot_price=current.spot_price,
                old_value=str(flip.get('gamma_before', 'N/A')),
                new_value=str(flip.get('gamma_after', 'N/A'))
            )
            alerts.append(alert)

        # 2. Regime Change alert
        if current.regime_flipped and previous:
            alert = Alert(
                alert_type=AlertType.REGIME_CHANGE.value,
                strike=None,
                message=f"Gamma regime shifted from {previous.gamma_regime} to {current.gamma_regime}",
                priority=AlertPriority.HIGH.value,
                spot_price=current.spot_price,
                old_value=previous.gamma_regime,
                new_value=current.gamma_regime
            )
            alerts.append(alert)

        # 3. Magnet Shift alert
        if previous and current.magnets:
            current_top = current.magnets[0]['strike'] if current.magnets else None
            previous_top = self.previous_magnets[0] if self.previous_magnets else None

            if current_top and previous_top and current_top != previous_top:
                alert = Alert(
                    alert_type=AlertType.MAGNET_SHIFT.value,
                    strike=current_top,
                    message=f"Top magnet shifted from {previous_top} to {current_top}",
                    priority=AlertPriority.HIGH.value,
                    spot_price=current.spot_price,
                    old_value=str(previous_top),
                    new_value=str(current_top)
                )
                alerts.append(alert)

        # 4. Danger Zone alerts
        for dz in current.danger_zones:
            alert = Alert(
                alert_type=AlertType.DANGER_ZONE.value,
                strike=dz['strike'],
                message=f"Strike {dz['strike']} entered {dz['danger_type']} zone (ROC: {dz['roc_5min']:.1f}%)",
                priority=AlertPriority.MEDIUM.value,
                spot_price=current.spot_price,
                new_value=dz['danger_type']
            )
            alerts.append(alert)

        # 5. Pin Zone Entry alert
        if current.likely_pin:
            distance_to_pin = abs(current.spot_price - current.likely_pin)
            pin_zone_threshold = current.spot_price * (self.PIN_ZONE_PROXIMITY_PCT / 100)

            if distance_to_pin <= pin_zone_threshold:
                alert = Alert(
                    alert_type=AlertType.PIN_ZONE_ENTRY.value,
                    strike=current.likely_pin,
                    message=f"SPY entered pin zone near {current.likely_pin} strike",
                    priority=AlertPriority.MEDIUM.value,
                    spot_price=current.spot_price
                )
                alerts.append(alert)

        # 6. Gamma Spike alerts
        for strike_data in current.strikes:
            if previous:
                # Find previous strike data
                prev_strike = next(
                    (s for s in previous.strikes if s.strike == strike_data.strike),
                    None
                )
                if prev_strike and prev_strike.net_gamma != 0:
                    change_pct = ((strike_data.net_gamma - prev_strike.net_gamma) /
                                  abs(prev_strike.net_gamma)) * 100
                    if change_pct >= self.GAMMA_SPIKE_THRESHOLD:
                        alert = Alert(
                            alert_type=AlertType.GAMMA_SPIKE.value,
                            strike=strike_data.strike,
                            message=f"Strike {strike_data.strike} gamma spiked +{change_pct:.0f}%",
                            priority=AlertPriority.HIGH.value,
                            spot_price=current.spot_price,
                            old_value=str(prev_strike.net_gamma),
                            new_value=str(strike_data.net_gamma)
                        )
                        alerts.append(alert)

        return alerts

    def process_options_chain(self, options_data: Dict, spot_price: float,
                               vix: float, expiration: str) -> GammaSnapshot:
        """
        Process raw options chain data into a GammaSnapshot.

        Args:
            options_data: Dict containing options chain from Tradier
            spot_price: Current spot price
            vix: Current VIX level
            expiration: Expiration date string

        Returns:
            GammaSnapshot with all calculated metrics
        """
        from zoneinfo import ZoneInfo
        CENTRAL_TZ = ZoneInfo("America/Chicago")
        timestamp = datetime.now(CENTRAL_TZ)
        market_status = self.get_market_status()

        # Extract strikes and calculate metrics
        strikes_data = []
        total_gamma = 0
        total_net_gamma = 0
        gamma_flips = []

        # Get previous strike data for comparison
        previous_strikes = {}
        if self.previous_snapshot:
            for s in self.previous_snapshot.strikes:
                previous_strikes[s.strike] = s

        # Calculate expected move from ATM options
        expected_move = 0
        atm_strike = round(spot_price)  # Simplified ATM finding

        # Process each strike from options data
        for strike_info in options_data.get('strikes', []):
            strike = strike_info.get('strike', 0)
            call_gamma = strike_info.get('call_gamma', 0)
            put_gamma = strike_info.get('put_gamma', 0)
            call_oi = strike_info.get('call_oi', 0)
            put_oi = strike_info.get('put_oi', 0)

            # Calculate raw net gamma
            raw_net_gamma = self.calculate_net_gamma(call_gamma, put_gamma, call_oi, put_oi)

            # Apply smoothing to reduce noise from Tradier Greeks recalculations
            # This uses median of recent readings and dampens suspicious large swings
            net_gamma = self._smooth_gamma_value(strike, raw_net_gamma, spot_price)

            # Update market open baseline (first 5 minutes of trading)
            self._update_market_open_baseline(strike, net_gamma)

            total_gamma += abs(net_gamma)
            total_net_gamma += net_gamma

            # Check for gamma flip
            prev_strike = previous_strikes.get(strike)
            prev_gamma = prev_strike.net_gamma if prev_strike else 0
            flipped, flip_dir = self.detect_gamma_flip(net_gamma, prev_gamma)

            if flipped:
                gamma_flips.append({
                    'strike': strike,
                    'direction': flip_dir,
                    'gamma_before': prev_gamma,
                    'gamma_after': net_gamma
                })

            # Update history for ROC calculation
            self.update_history(strike, net_gamma, timestamp)

            # Calculate ROC at multiple timeframes
            history = self.history.get(strike, [])
            roc_1min = self.calculate_roc(strike, net_gamma, history, minutes=1)
            roc_5min = self.calculate_roc(strike, net_gamma, history, minutes=5)
            roc_30min = self.calculate_roc(strike, net_gamma, history, minutes=30)
            roc_1hr = self.calculate_roc(strike, net_gamma, history, minutes=60)
            roc_4hr = self.calculate_roc(strike, net_gamma, history, minutes=240)
            roc_trading_day = self.calculate_roc_since_open(net_gamma, history, strike=strike)

            # Calculate gamma change percentage
            gamma_change_pct = 0
            if prev_gamma and prev_gamma != 0:
                gamma_change_pct = ((net_gamma - prev_gamma) / abs(prev_gamma)) * 100

            strike_data = StrikeData(
                strike=strike,
                net_gamma=net_gamma,
                call_gamma=call_gamma,
                put_gamma=put_gamma,
                gamma_change_pct=round(gamma_change_pct, 2),
                roc_1min=roc_1min,
                roc_5min=roc_5min,
                roc_30min=roc_30min,
                roc_1hr=roc_1hr,
                roc_4hr=roc_4hr,
                roc_trading_day=roc_trading_day,
                volume=strike_info.get('volume', 0),
                call_iv=strike_info.get('call_iv', 0),
                put_iv=strike_info.get('put_iv', 0),
                previous_net_gamma=prev_gamma,
                gamma_flipped=flipped,
                flip_direction=flip_dir
            )
            strikes_data.append(strike_data)

            # Calculate expected move from ATM
            if strike == atm_strike:
                call_price = strike_info.get('call_price', 0)
                put_price = strike_info.get('put_price', 0)
                expected_move = self.calculate_expected_move(call_price, put_price)

        # Default expected move if not calculated
        if expected_move == 0:
            expected_move = spot_price * 0.01  # 1% default

        # Build gamma_structure for ML predictions
        # Find magnets early (top 3 by gamma magnitude)
        sorted_by_gamma = sorted(strikes_data, key=lambda s: abs(s.net_gamma), reverse=True)
        top_magnets = [{'strike': s.strike, 'gamma': s.net_gamma} for s in sorted_by_gamma[:3]]

        # Calculate flip point (weighted average of positive/negative gamma centers)
        positive_strikes = [s for s in strikes_data if s.net_gamma > 0]
        negative_strikes = [s for s in strikes_data if s.net_gamma < 0]
        if positive_strikes and negative_strikes:
            pos_center = sum(s.strike * abs(s.net_gamma) for s in positive_strikes) / sum(abs(s.net_gamma) for s in positive_strikes)
            neg_center = sum(s.strike * abs(s.net_gamma) for s in negative_strikes) / sum(abs(s.net_gamma) for s in negative_strikes)
            flip_point = (pos_center + neg_center) / 2
        else:
            flip_point = spot_price

        # Build gamma_structure for ML
        gamma_structure = {
            'net_gamma': total_net_gamma,
            'total_gamma': total_gamma,
            'flip_point': flip_point,
            'magnets': top_magnets,
            'vix': vix,
            'gamma_regime': self.classify_gamma_regime(total_net_gamma),
            'expected_move': expected_move,
            'spot_price': spot_price
        }

        # Calculate probabilities for all strikes using gamma_structure
        for strike_data in strikes_data:
            strike_data.probability = self.calculate_probability_hybrid(
                strike_data.strike,
                spot_price,
                strike_data.net_gamma,
                total_gamma,
                expected_move,
                gamma_structure  # Pass gamma_structure for ML predictions
            )

        # Normalize probabilities to sum to 100%
        total_prob = sum(s.probability for s in strikes_data)
        if total_prob > 0:
            for s in strikes_data:
                s.probability = round((s.probability / total_prob) * 100, 1)

        # Classify overall regime
        gamma_regime = self.classify_gamma_regime(total_net_gamma)
        previous_regime = self.previous_snapshot.gamma_regime if self.previous_snapshot else None
        regime_flipped = previous_regime is not None and gamma_regime != previous_regime

        # Lock GEX levels at market open (like SpotGamma does for 0DTE)
        # This ensures major strikes remain stable throughout the day
        self.lock_gex_levels_at_open(strikes_data, spot_price)

        # Identify magnets, pin, and danger zones
        magnets = self.identify_magnets(strikes_data)
        likely_pin, pin_probability = self.identify_pin_strike(strikes_data, spot_price)
        danger_zones = self.identify_danger_zones(strikes_data)

        # Detect pinning condition (no danger zones = stable gamma = likely pinning)
        pinning_status = self.detect_pinning_condition(strikes_data, spot_price, likely_pin, danger_zones)

        # Create snapshot
        symbol = options_data.get('symbol', 'SPY')  # Get symbol from data, default to SPY
        snapshot = GammaSnapshot(
            symbol=symbol,
            expiration_date=expiration,
            snapshot_time=timestamp,
            spot_price=spot_price,
            expected_move=expected_move,
            vix=vix,
            total_net_gamma=total_net_gamma,
            gamma_regime=gamma_regime,
            previous_regime=previous_regime,
            regime_flipped=regime_flipped,
            market_status=market_status,
            strikes=strikes_data,
            magnets=magnets,
            likely_pin=likely_pin,
            pin_probability=pin_probability,
            danger_zones=danger_zones,
            gamma_flips=gamma_flips,
            pinning_status=pinning_status
        )

        # Generate alerts
        self.alerts = self.generate_alerts(snapshot, self.previous_snapshot)

        # Update state for next iteration
        self.previous_snapshot = snapshot
        self.previous_magnets = [m['strike'] for m in magnets]
        self._previous_spot_price = spot_price  # Track for smoothing validation

        return snapshot

    def filter_strikes_by_expected_move(self, strikes: List[StrikeData],
                                         spot_price: float,
                                         expected_move: float,
                                         extra_strikes: int = 5) -> List[StrikeData]:
        """
        Filter strikes to only include those within expected move ± extra strikes.

        Args:
            strikes: All strike data
            spot_price: Current spot price
            expected_move: Expected move in dollars
            extra_strikes: Number of strikes outside expected move to include

        Returns:
            Filtered list of strikes
        """
        lower_bound = spot_price - expected_move
        upper_bound = spot_price + expected_move

        # Sort strikes by distance from bounds
        def in_range_priority(s):
            if lower_bound <= s.strike <= upper_bound:
                return 0
            elif s.strike < lower_bound:
                return lower_bound - s.strike
            else:
                return s.strike - upper_bound

        sorted_strikes = sorted(strikes, key=in_range_priority)

        # Get strikes within expected move
        in_range = [s for s in sorted_strikes if lower_bound <= s.strike <= upper_bound]

        # Get extra strikes outside
        outside_lower = sorted([s for s in strikes if s.strike < lower_bound],
                                key=lambda x: x.strike, reverse=True)[:extra_strikes]
        outside_upper = sorted([s for s in strikes if s.strike > upper_bound],
                                key=lambda x: x.strike)[:extra_strikes]

        # Combine and sort by strike
        all_strikes = in_range + outside_lower + outside_upper
        return sorted(all_strikes, key=lambda s: s.strike)

    def get_active_alerts(self) -> List[Dict]:
        """Get list of active (unacknowledged) alerts"""
        return [a.to_dict() for a in self.alerts]

    def get_gamma_snapshot(self, symbol: str = "SPY") -> Optional[Dict]:
        """
        Get the current gamma snapshot as a dictionary.

        This returns the most recently processed snapshot from process_options_chain().
        Returns None if no snapshot has been processed yet.

        Args:
            symbol: Symbol to get snapshot for (currently ignored, uses stored snapshot)

        Returns:
            Dict with gamma data including strikes, spot_price, gamma_regime, etc.
            None if no data available.
        """
        if self.previous_snapshot is None:
            return None

        # Convert to dict and add flip_point for backwards compatibility
        snapshot_dict = self.previous_snapshot.to_dict()

        # Add flip_point if not present (computed from magnets/structure)
        if 'flip_point' not in snapshot_dict:
            # Flip point is typically near the largest gamma magnitude strike
            strikes = snapshot_dict.get('strikes', [])
            if strikes:
                # Find the strike closest to spot with highest gamma
                spot = snapshot_dict.get('spot_price', 0)
                near_strikes = [s for s in strikes if abs(s.get('strike', 0) - spot) / spot < 0.02] if spot > 0 else strikes[:5]
                if near_strikes:
                    max_gamma_strike = max(near_strikes, key=lambda s: abs(s.get('net_gamma', 0)))
                    snapshot_dict['flip_point'] = max_gamma_strike.get('strike', spot)
                else:
                    snapshot_dict['flip_point'] = spot
            else:
                snapshot_dict['flip_point'] = snapshot_dict.get('spot_price', 0)

        return snapshot_dict

    def acknowledge_alert(self, alert_index: int) -> bool:
        """Acknowledge an alert by index"""
        if 0 <= alert_index < len(self.alerts):
            # In production, this would update the database
            return True
        return False


# Singleton instance
_argus_engine: Optional[ArgusEngine] = None


def get_argus_engine() -> ArgusEngine:
    """Get or create the singleton ARGUS engine instance"""
    global _argus_engine
    if _argus_engine is None:
        _argus_engine = ArgusEngine()
    return _argus_engine


def initialize_argus_engine() -> ArgusEngine:
    """
    Initialize ARGUS engine with eager loading of ML models.
    Call this at application startup to avoid cold-start latency.
    """
    engine = get_argus_engine()
    # Eagerly load ML models to avoid first-request delay
    engine._get_ml_models()
    logger.info("ARGUS engine initialized with ML models pre-loaded")
    return engine
