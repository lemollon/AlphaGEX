"""
ARGUS Engine - 0DTE Gamma Live Analysis
=========================================

Named after Argus Panoptes, the "all-seeing" giant with 100 eyes from Greek mythology.
Real-time visualization of net gamma by strike with ML-powered probability predictions.

Features:
- Net gamma calculation per strike
- Gamma flip detection (positive ↔ negative)
- Hybrid probability calculation (ML + gamma-weighted distance)
- Rate of change indicators (1-min and 5-min)
- Magnet, pin, and danger zone detection

Author: AlphaGEX Team
"""

import os
import sys
import logging
from datetime import datetime, timedelta, date
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field, asdict
from enum import Enum
import math
import json

import numpy as np
import pandas as pd

# Add parent directory for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from dotenv import load_dotenv
load_dotenv()

logger = logging.getLogger(__name__)


class GammaRegime(Enum):
    """Overall gamma regime classification"""
    POSITIVE = "POSITIVE"
    NEGATIVE = "NEGATIVE"
    NEUTRAL = "NEUTRAL"


class FlipDirection(Enum):
    """Direction of gamma flip"""
    POS_TO_NEG = "POS_TO_NEG"
    NEG_TO_POS = "NEG_TO_POS"


class DangerType(Enum):
    """Type of danger zone"""
    BUILDING = "BUILDING"      # Gamma accumulating rapidly (>+25% in 5 min)
    COLLAPSING = "COLLAPSING"  # Gamma evaporating (<-25% in 5 min)
    SPIKE = "SPIKE"            # Sudden gamma surge (>+15% in 1 min)


class AlertType(Enum):
    """Types of alerts"""
    GAMMA_FLIP = "GAMMA_FLIP"
    REGIME_CHANGE = "REGIME_CHANGE"
    GAMMA_SPIKE = "GAMMA_SPIKE"
    MAGNET_SHIFT = "MAGNET_SHIFT"
    PIN_ZONE_ENTRY = "PIN_ZONE_ENTRY"
    DANGER_ZONE = "DANGER_ZONE"
    GAMMA_COLLAPSE = "GAMMA_COLLAPSE"
    PATTERN_MATCH = "PATTERN_MATCH"


class AlertPriority(Enum):
    """Alert priority levels"""
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"


@dataclass
class StrikeData:
    """Data for a single strike"""
    strike: float
    net_gamma: float
    call_gamma: float = 0.0
    put_gamma: float = 0.0
    probability: float = 0.0
    gamma_change_pct: float = 0.0
    roc_1min: float = 0.0
    roc_5min: float = 0.0
    roc_30min: float = 0.0
    roc_1hr: float = 0.0
    roc_4hr: float = 0.0
    roc_trading_day: float = 0.0  # ROC since market open (8:30 AM CT)
    volume: int = 0
    call_iv: float = 0.0
    put_iv: float = 0.0
    is_magnet: bool = False
    magnet_rank: Optional[int] = None
    is_pin: bool = False
    is_danger: bool = False
    danger_type: Optional[str] = None
    gamma_flipped: bool = False
    flip_direction: Optional[str] = None
    previous_net_gamma: float = 0.0

    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class GammaSnapshot:
    """Complete gamma snapshot at a point in time"""
    symbol: str
    expiration_date: str
    snapshot_time: datetime
    spot_price: float
    expected_move: float
    vix: float
    total_net_gamma: float
    gamma_regime: str
    previous_regime: Optional[str]
    regime_flipped: bool
    market_status: str
    strikes: List[StrikeData]
    magnets: List[Dict]
    likely_pin: float
    pin_probability: float
    danger_zones: List[Dict]
    gamma_flips: List[Dict]
    pinning_status: Dict = field(default_factory=lambda: {'is_pinning': False})

    def to_dict(self) -> Dict:
        return {
            'symbol': self.symbol,
            'expiration_date': self.expiration_date,
            'snapshot_time': self.snapshot_time.isoformat(),
            'spot_price': self.spot_price,
            'expected_move': self.expected_move,
            'vix': self.vix,
            'total_net_gamma': self.total_net_gamma,
            'gamma_regime': self.gamma_regime,
            'previous_regime': self.previous_regime,
            'regime_flipped': self.regime_flipped,
            'market_status': self.market_status,
            'strikes': [s.to_dict() for s in self.strikes],
            'magnets': self.magnets,
            'likely_pin': self.likely_pin,
            'pin_probability': self.pin_probability,
            'danger_zones': self.danger_zones,
            'gamma_flips': self.gamma_flips,
            'pinning_status': self.pinning_status
        }


@dataclass
class Alert:
    """Alert generated by the system"""
    alert_type: str
    strike: Optional[float]
    message: str
    priority: str
    spot_price: float
    old_value: Optional[str] = None
    new_value: Optional[str] = None
    triggered_at: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> Dict:
        return {
            'alert_type': self.alert_type,
            'strike': self.strike,
            'message': self.message,
            'priority': self.priority,
            'spot_price': self.spot_price,
            'old_value': self.old_value,
            'new_value': self.new_value,
            'triggered_at': self.triggered_at.isoformat()
        }


class ArgusEngine:
    """
    Core engine for ARGUS 0DTE Gamma Live analysis.

    Responsibilities:
    - Fetch and process gamma data from Tradier
    - Calculate net gamma per strike
    - Detect gamma flips (positive ↔ negative)
    - Calculate probabilities using hybrid approach
    - Identify magnets, pins, and danger zones
    - Generate alerts for significant events
    """

    # Thresholds - keep high to only show REAL spikes
    ROC_1MIN_SPIKE_THRESHOLD = 15.0  # % for SPIKE danger type
    ROC_5MIN_BUILDING_THRESHOLD = 25.0  # % for BUILDING danger type
    ROC_5MIN_COLLAPSING_THRESHOLD = -25.0  # % for COLLAPSING danger type
    PIN_ZONE_PROXIMITY_PCT = 0.5  # % distance from likely pin
    GAMMA_SPIKE_THRESHOLD = 50.0  # % increase in 5 min for alert
    GAMMA_COLLAPSE_THRESHOLD = -20.0  # % decrease in 10 min for alert

    def __init__(self):
        """Initialize the ARGUS engine"""
        self.previous_snapshot: Optional[GammaSnapshot] = None
        self.history: Dict[float, List[Tuple[datetime, float]]] = {}  # strike -> [(time, gamma)]
        self.previous_magnets: List[float] = []
        self.alerts: List[Alert] = []

        # Import ML models lazily to avoid circular imports
        self._ml_models = None

        # Expected move smoothing state
        # EMA smoothing reduces chart structure volatility by ~70-80%
        self._previous_expected_move: Optional[float] = None
        self._ema_alpha: float = 0.3  # 30% new value, 70% previous (tunable)

    def reset_expected_move_smoothing(self):
        """
        Reset the expected move smoothing state.

        Call this at the start of a new trading day or when you want
        the expected move to immediately reflect current option prices
        without smoothing from previous values.
        """
        self._previous_expected_move = None
        logger.debug("Expected move smoothing state reset")

    def set_ema_alpha(self, alpha: float):
        """
        Set the EMA smoothing factor for expected move.

        Args:
            alpha: Value between 0 and 1. Higher = more responsive to changes,
                   lower = more stable/smooth. Default is 0.3.
                   - 0.1 = very smooth (90% previous, 10% new)
                   - 0.3 = balanced (70% previous, 30% new) [default]
                   - 0.5 = responsive (50% previous, 50% new)
        """
        if not 0 < alpha <= 1:
            raise ValueError("Alpha must be between 0 (exclusive) and 1 (inclusive)")
        self._ema_alpha = alpha
        logger.info(f"Expected move EMA alpha set to {alpha}")

    def _get_ml_models(self):
        """Lazy load ML probability models"""
        if self._ml_models is None:
            try:
                from quant.gex_probability_models import GEXProbabilityModels
                self._ml_models = GEXProbabilityModels()
                logger.info("Loaded GEX probability models for ARGUS")
            except Exception as e:
                logger.warning(f"Could not load ML models: {e}")
                self._ml_models = False
        return self._ml_models if self._ml_models else None

    def get_market_status(self) -> str:
        """Determine current market status based on time, including holidays"""
        from zoneinfo import ZoneInfo
        CENTRAL_TZ = ZoneInfo("America/Chicago")
        now = datetime.now(CENTRAL_TZ)
        hour = now.hour
        minute = now.minute

        # Weekend check
        if now.weekday() >= 5:
            return 'closed'

        # Holiday check - use MarketCalendar holidays
        from trading.market_calendar import MARKET_HOLIDAYS_2024_2025
        date_str = now.strftime('%Y-%m-%d')
        if date_str in MARKET_HOLIDAYS_2024_2025:
            return 'holiday'

        time_minutes = hour * 60 + minute

        # Pre-market: 4:00am - 8:30am CT (5:00am - 9:30am ET)
        if 4 * 60 <= time_minutes < 8 * 60 + 30:
            return 'pre_market'
        # Market hours: 8:30am - 3:00pm CT (9:30am - 4:00pm ET)
        elif 8 * 60 + 30 <= time_minutes < 15 * 60:
            return 'open'
        # After hours: 3:00pm - 7:00pm CT (4:00pm - 8:00pm ET)
        elif 15 * 60 <= time_minutes < 19 * 60:
            return 'after_hours'
        else:
            return 'closed'

    def get_0dte_expiration(self, target_day: str = 'today') -> str:
        """
        Get the 0DTE expiration date.
        SPY has 0DTE every day (Mon-Fri).

        Args:
            target_day: 'today', 'mon', 'tue', 'wed', 'thu', 'fri'

        Returns:
            Expiration date string in YYYY-MM-DD format
        """
        today = date.today()

        if target_day == 'today':
            # If weekend, return next Monday
            if today.weekday() >= 5:
                days_until_monday = 7 - today.weekday()
                return (today + timedelta(days=days_until_monday)).strftime('%Y-%m-%d')
            return today.strftime('%Y-%m-%d')

        # Map day names to weekday numbers
        day_map = {'mon': 0, 'tue': 1, 'wed': 2, 'thu': 3, 'fri': 4}
        target_weekday = day_map.get(target_day.lower(), today.weekday())

        # Calculate days until target
        days_ahead = target_weekday - today.weekday()
        if days_ahead < 0:
            days_ahead += 7

        target_date = today + timedelta(days=days_ahead)
        return target_date.strftime('%Y-%m-%d')

    def calculate_expected_move(self, atm_call_price: float, atm_put_price: float,
                                  apply_smoothing: bool = True) -> float:
        """
        Calculate expected move from ATM straddle price with optional EMA smoothing.

        Smoothing reduces chart structure volatility by dampening rapid changes
        in expected move that cause strike filtering bounds to shift frequently.

        Args:
            atm_call_price: Price of ATM call
            atm_put_price: Price of ATM put
            apply_smoothing: Whether to apply EMA smoothing (default True)

        Returns:
            Expected move in dollars (smoothed if enabled)
        """
        raw_em = atm_call_price + atm_put_price

        if not apply_smoothing or raw_em <= 0:
            return raw_em

        # Apply exponential moving average smoothing
        if self._previous_expected_move is None:
            # First calculation - use raw value
            smoothed_em = raw_em
        else:
            # EMA: smoothed = alpha * new + (1 - alpha) * previous
            smoothed_em = (self._ema_alpha * raw_em +
                          (1 - self._ema_alpha) * self._previous_expected_move)

        # Update state for next calculation
        self._previous_expected_move = smoothed_em

        return smoothed_em

    def calculate_net_gamma(self, call_gamma: float, put_gamma: float,
                            call_oi: int = 0, put_oi: int = 0) -> float:
        """
        Calculate net gamma at a strike.

        Net gamma = call_gamma * call_OI * 100 + put_gamma * put_OI * 100
        (Both should be positive as they measure absolute exposure)

        For visualization, we show the sum as net gamma affects dealer hedging.
        """
        # Gamma is always positive, but we multiply by OI and contract multiplier
        call_exposure = abs(call_gamma) * call_oi * 100 if call_oi else abs(call_gamma)
        put_exposure = abs(put_gamma) * put_oi * 100 if put_oi else abs(put_gamma)

        # Net gamma is typically calls - puts for directional bias
        # Positive = calls dominate (dealers hedging by buying)
        # Negative = puts dominate (dealers hedging by selling)
        return call_exposure - put_exposure

    def detect_gamma_flip(self, current_gamma: float, previous_gamma: float) -> Tuple[bool, Optional[str]]:
        """
        Detect if gamma flipped from positive to negative or vice versa.

        Returns:
            Tuple of (flipped: bool, direction: Optional[str])
        """
        if previous_gamma is None or previous_gamma == 0:
            return False, None

        # Check for sign change
        if current_gamma > 0 and previous_gamma < 0:
            return True, FlipDirection.NEG_TO_POS.value
        elif current_gamma < 0 and previous_gamma > 0:
            return True, FlipDirection.POS_TO_NEG.value

        return False, None

    def classify_gamma_regime(self, total_net_gamma: float) -> str:
        """
        Classify overall gamma regime based on total net gamma.

        Returns:
            POSITIVE, NEGATIVE, or NEUTRAL
        """
        # Threshold for neutral zone (can be tuned)
        neutral_threshold = 1e9  # $1B

        if total_net_gamma > neutral_threshold:
            return GammaRegime.POSITIVE.value
        elif total_net_gamma < -neutral_threshold:
            return GammaRegime.NEGATIVE.value
        else:
            return GammaRegime.NEUTRAL.value

    def calculate_probability_hybrid(self, strike: float, spot_price: float,
                                     net_gamma: float, total_gamma: float,
                                     expected_move: float,
                                     gamma_structure: Dict = None) -> float:
        """
        Calculate probability of price landing at a strike using hybrid approach.

        60% ML model + 40% gamma-weighted distance

        Args:
            strike: Strike price
            spot_price: Current spot price
            net_gamma: Net gamma at this strike
            total_gamma: Total absolute gamma across all strikes
            expected_move: Expected move in dollars
            gamma_structure: Optional structure for ML model

        Returns:
            Probability as percentage (0-100)
        """
        # Distance component (40% weight)
        distance_from_spot = abs(strike - spot_price)
        gamma_magnitude = abs(net_gamma)

        # Avoid division by zero
        if total_gamma == 0:
            total_gamma = 1

        # Gamma weight (higher gamma = more likely to attract)
        gamma_weight = gamma_magnitude / total_gamma

        # Distance decay (exponential decay based on expected move)
        if expected_move > 0:
            distance_decay = math.exp(-distance_from_spot / expected_move)
        else:
            distance_decay = 1.0 if distance_from_spot == 0 else 0.0

        distance_probability = gamma_weight * distance_decay * 100

        # ML component (60% weight) - try to use ML models
        ml_probability = distance_probability  # Default to distance if no ML

        ml_models = self._get_ml_models()
        if ml_models and gamma_structure:
            try:
                ml_result = ml_models.predict_magnet_attraction(
                    strike, spot_price, gamma_structure
                )
                if ml_result and 'probability' in ml_result:
                    ml_probability = ml_result['probability'] * 100
            except Exception as e:
                logger.debug(f"ML prediction failed, using distance only: {e}")

        # Combined probability
        combined = (0.6 * ml_probability) + (0.4 * distance_probability)

        return combined

    def calculate_roc(self, strike: float, current_gamma: float,
                      history: List[Tuple[datetime, float]],
                      minutes: int = 1) -> float:
        """
        Calculate rate of change for a strike over specified minutes.

        Args:
            strike: Strike price
            current_gamma: Current gamma value
            history: List of (timestamp, gamma) tuples
            minutes: Number of minutes to look back (1, 5, 30, 60, 240)

        Returns:
            Rate of change as percentage
        """
        if not history or len(history) < 2:
            return 0.0

        from zoneinfo import ZoneInfo
        CENTRAL_TZ = ZoneInfo("America/Chicago")

        # Find value from X minutes ago - use timezone-aware datetime
        target_time = datetime.now(CENTRAL_TZ) - timedelta(minutes=minutes)
        old_gamma = None

        for timestamp, gamma in reversed(history):
            # Handle timezone-aware comparison
            if timestamp.tzinfo is None:
                timestamp = timestamp.replace(tzinfo=CENTRAL_TZ)
            if timestamp <= target_time:
                old_gamma = gamma
                break

        if old_gamma is None or old_gamma == 0:
            return 0.0

        roc = ((current_gamma - old_gamma) / abs(old_gamma)) * 100
        return round(roc, 2)

    def calculate_roc_since_open(self, current_gamma: float,
                                  history: List[Tuple[datetime, float]]) -> float:
        """
        Calculate rate of change since market open (8:30 AM CT).

        Args:
            current_gamma: Current gamma value
            history: List of (timestamp, gamma) tuples

        Returns:
            Rate of change as percentage since market open
        """
        if not history or len(history) < 1:
            return 0.0

        from zoneinfo import ZoneInfo
        CENTRAL_TZ = ZoneInfo("America/Chicago")
        now = datetime.now(CENTRAL_TZ)

        # Market open is 8:30 AM CT
        market_open = now.replace(hour=8, minute=30, second=0, microsecond=0)

        # If it's before market open today, no trading day ROC available
        if now < market_open:
            return 0.0

        # Find the first gamma value after market open
        open_gamma = None
        for timestamp, gamma in history:
            # Handle timezone-aware comparison
            if timestamp.tzinfo is None:
                timestamp = timestamp.replace(tzinfo=CENTRAL_TZ)
            if timestamp >= market_open:
                open_gamma = gamma
                break

        if open_gamma is None or open_gamma == 0:
            return 0.0

        roc = ((current_gamma - open_gamma) / abs(open_gamma)) * 100
        return round(roc, 2)

    def update_history(self, strike: float, gamma: float, timestamp: datetime = None):
        """Update gamma history for a strike"""
        from zoneinfo import ZoneInfo
        CENTRAL_TZ = ZoneInfo("America/Chicago")

        if timestamp is None:
            timestamp = datetime.now(CENTRAL_TZ)

        # Ensure timestamp is timezone-aware
        if timestamp.tzinfo is None:
            timestamp = timestamp.replace(tzinfo=CENTRAL_TZ)

        if strike not in self.history:
            self.history[strike] = []

        self.history[strike].append((timestamp, gamma))

        # Keep history for full trading day (7 hours = 420 minutes to cover pre-market to close)
        cutoff = timestamp - timedelta(minutes=420)
        self.history[strike] = [
            (t, g) for t, g in self.history[strike]
            if (t.replace(tzinfo=CENTRAL_TZ) if t.tzinfo is None else t) >= cutoff
        ]

    def identify_magnets(self, strikes: List[StrikeData], top_n: int = 3) -> List[Dict]:
        """
        Identify top N gamma magnets (strikes with highest absolute gamma).

        Returns:
            List of dicts with strike and gamma info
        """
        sorted_strikes = sorted(strikes, key=lambda s: abs(s.net_gamma), reverse=True)

        magnets = []
        for i, strike_data in enumerate(sorted_strikes[:top_n]):
            magnets.append({
                'rank': i + 1,
                'strike': strike_data.strike,
                'net_gamma': strike_data.net_gamma,
                'probability': strike_data.probability
            })
            strike_data.is_magnet = True
            strike_data.magnet_rank = i + 1

        return magnets

    def identify_pin_strike(self, strikes: List[StrikeData], spot_price: float) -> Tuple[float, float]:
        """
        Identify the likely pin strike.

        Pin score = (probability * 0.4) + (gamma_rank * 0.3) + (proximity_score * 0.3)

        Returns:
            Tuple of (pin_strike, pin_probability)
        """
        if not strikes:
            return 0.0, 0.0

        best_pin = None
        best_score = -1

        # Rank strikes by gamma
        sorted_by_gamma = sorted(strikes, key=lambda s: abs(s.net_gamma), reverse=True)
        gamma_ranks = {s.strike: i + 1 for i, s in enumerate(sorted_by_gamma)}

        for strike_data in strikes:
            # Probability component (0-1, higher is better)
            prob_score = strike_data.probability / 100

            # Gamma rank component (1 is best, invert so higher is better)
            gamma_rank = gamma_ranks.get(strike_data.strike, len(strikes))
            gamma_score = 1 - (gamma_rank / len(strikes))

            # Proximity score (closer to spot is better)
            distance = abs(strike_data.strike - spot_price)
            max_distance = max(abs(s.strike - spot_price) for s in strikes) or 1
            proximity_score = 1 - (distance / max_distance)

            # Combined score
            pin_score = (prob_score * 0.4) + (gamma_score * 0.3) + (proximity_score * 0.3)

            if pin_score > best_score:
                best_score = pin_score
                best_pin = strike_data

        if best_pin:
            best_pin.is_pin = True
            return best_pin.strike, best_pin.probability

        return 0.0, 0.0

    def identify_danger_zones(self, strikes: List[StrikeData]) -> List[Dict]:
        """
        Identify danger zones - strikes with rapid gamma changes.

        Thresholds:
        - BUILDING: 5-min ROC > +25%
        - COLLAPSING: 5-min ROC < -25%
        - SPIKE: 1-min ROC > +15%
        """
        danger_zones = []

        for strike_data in strikes:
            danger_type = None

            if strike_data.roc_5min >= self.ROC_5MIN_BUILDING_THRESHOLD:
                danger_type = DangerType.BUILDING.value
            elif strike_data.roc_5min <= self.ROC_5MIN_COLLAPSING_THRESHOLD:
                danger_type = DangerType.COLLAPSING.value
            elif strike_data.roc_1min >= self.ROC_1MIN_SPIKE_THRESHOLD:
                danger_type = DangerType.SPIKE.value

            if danger_type:
                strike_data.is_danger = True
                strike_data.danger_type = danger_type
                danger_zones.append({
                    'strike': strike_data.strike,
                    'danger_type': danger_type,
                    'roc_1min': strike_data.roc_1min,
                    'roc_5min': strike_data.roc_5min
                })

        return danger_zones

    def detect_pinning_condition(
        self,
        strikes: List[StrikeData],
        spot_price: float,
        likely_pin: float,
        danger_zones: List[Dict]
    ) -> Dict:
        """
        Detect if the market is in a "pinning" condition.

        Pinning is detected when:
        1. No danger zones (gamma is stable, no significant ROC)
        2. Spot price is within 0.5% of likely pin strike
        3. Average absolute ROC is low (< 5%)

        Returns:
            Dict with pinning status and details
        """
        if not strikes or not likely_pin:
            return {'is_pinning': False}

        # Check 1: No danger zones
        has_no_danger = len(danger_zones) == 0

        # Check 2: Spot is close to pin (within 0.5%)
        distance_to_pin_pct = abs(spot_price - likely_pin) / spot_price * 100 if spot_price > 0 else 100
        is_near_pin = distance_to_pin_pct < 0.5

        # Check 3: Average ROC is low (stable gamma)
        roc_values = []
        for s in strikes:
            roc_values.extend([abs(s.roc_1min), abs(s.roc_5min)])

        avg_roc = sum(roc_values) / len(roc_values) if roc_values else 0
        is_stable = avg_roc < 5.0  # Less than 5% average movement

        # Determine pinning status
        is_pinning = has_no_danger and (is_near_pin or is_stable)

        if is_pinning:
            if is_near_pin:
                message = f"PINNING: Price is pinning near ${likely_pin} strike (within {distance_to_pin_pct:.2f}%). Gamma stable, expect tight range."
            else:
                message = f"STABLE: No gamma movement detected (avg ROC: {avg_roc:.1f}%). Price likely to gravitate toward ${likely_pin} pin."

            return {
                'is_pinning': True,
                'pin_strike': likely_pin,
                'distance_to_pin_pct': round(distance_to_pin_pct, 2),
                'avg_roc': round(avg_roc, 2),
                'message': message,
                'trade_idea': 'Iron Condor or Credit Spread around pin strike may be favorable.'
            }

        return {'is_pinning': False}

    def generate_alerts(self, current: GammaSnapshot, previous: Optional[GammaSnapshot]) -> List[Alert]:
        """
        Generate alerts based on current snapshot vs previous.
        """
        alerts = []

        # 1. Gamma Flip alerts
        for flip in current.gamma_flips:
            alert = Alert(
                alert_type=AlertType.GAMMA_FLIP.value,
                strike=flip['strike'],
                message=f"Strike {flip['strike']} gamma flipped {flip['direction']}",
                priority=AlertPriority.HIGH.value,
                spot_price=current.spot_price,
                old_value=str(flip.get('gamma_before', 'N/A')),
                new_value=str(flip.get('gamma_after', 'N/A'))
            )
            alerts.append(alert)

        # 2. Regime Change alert
        if current.regime_flipped and previous:
            alert = Alert(
                alert_type=AlertType.REGIME_CHANGE.value,
                strike=None,
                message=f"Gamma regime shifted from {previous.gamma_regime} to {current.gamma_regime}",
                priority=AlertPriority.HIGH.value,
                spot_price=current.spot_price,
                old_value=previous.gamma_regime,
                new_value=current.gamma_regime
            )
            alerts.append(alert)

        # 3. Magnet Shift alert
        if previous and current.magnets:
            current_top = current.magnets[0]['strike'] if current.magnets else None
            previous_top = self.previous_magnets[0] if self.previous_magnets else None

            if current_top and previous_top and current_top != previous_top:
                alert = Alert(
                    alert_type=AlertType.MAGNET_SHIFT.value,
                    strike=current_top,
                    message=f"Top magnet shifted from {previous_top} to {current_top}",
                    priority=AlertPriority.HIGH.value,
                    spot_price=current.spot_price,
                    old_value=str(previous_top),
                    new_value=str(current_top)
                )
                alerts.append(alert)

        # 4. Danger Zone alerts
        for dz in current.danger_zones:
            alert = Alert(
                alert_type=AlertType.DANGER_ZONE.value,
                strike=dz['strike'],
                message=f"Strike {dz['strike']} entered {dz['danger_type']} zone (ROC: {dz['roc_5min']:.1f}%)",
                priority=AlertPriority.MEDIUM.value,
                spot_price=current.spot_price,
                new_value=dz['danger_type']
            )
            alerts.append(alert)

        # 5. Pin Zone Entry alert
        if current.likely_pin:
            distance_to_pin = abs(current.spot_price - current.likely_pin)
            pin_zone_threshold = current.spot_price * (self.PIN_ZONE_PROXIMITY_PCT / 100)

            if distance_to_pin <= pin_zone_threshold:
                alert = Alert(
                    alert_type=AlertType.PIN_ZONE_ENTRY.value,
                    strike=current.likely_pin,
                    message=f"SPY entered pin zone near {current.likely_pin} strike",
                    priority=AlertPriority.MEDIUM.value,
                    spot_price=current.spot_price
                )
                alerts.append(alert)

        # 6. Gamma Spike alerts
        for strike_data in current.strikes:
            if previous:
                # Find previous strike data
                prev_strike = next(
                    (s for s in previous.strikes if s.strike == strike_data.strike),
                    None
                )
                if prev_strike and prev_strike.net_gamma != 0:
                    change_pct = ((strike_data.net_gamma - prev_strike.net_gamma) /
                                  abs(prev_strike.net_gamma)) * 100
                    if change_pct >= self.GAMMA_SPIKE_THRESHOLD:
                        alert = Alert(
                            alert_type=AlertType.GAMMA_SPIKE.value,
                            strike=strike_data.strike,
                            message=f"Strike {strike_data.strike} gamma spiked +{change_pct:.0f}%",
                            priority=AlertPriority.HIGH.value,
                            spot_price=current.spot_price,
                            old_value=str(prev_strike.net_gamma),
                            new_value=str(strike_data.net_gamma)
                        )
                        alerts.append(alert)

        return alerts

    def process_options_chain(self, options_data: Dict, spot_price: float,
                               vix: float, expiration: str) -> GammaSnapshot:
        """
        Process raw options chain data into a GammaSnapshot.

        Args:
            options_data: Dict containing options chain from Tradier
            spot_price: Current spot price
            vix: Current VIX level
            expiration: Expiration date string

        Returns:
            GammaSnapshot with all calculated metrics
        """
        from zoneinfo import ZoneInfo
        CENTRAL_TZ = ZoneInfo("America/Chicago")
        timestamp = datetime.now(CENTRAL_TZ)
        market_status = self.get_market_status()

        # Extract strikes and calculate metrics
        strikes_data = []
        total_gamma = 0
        total_net_gamma = 0
        gamma_flips = []

        # Get previous strike data for comparison
        previous_strikes = {}
        if self.previous_snapshot:
            for s in self.previous_snapshot.strikes:
                previous_strikes[s.strike] = s

        # Calculate expected move from ATM options
        expected_move = 0
        atm_strike = round(spot_price)  # Simplified ATM finding

        # Process each strike from options data
        for strike_info in options_data.get('strikes', []):
            strike = strike_info.get('strike', 0)
            call_gamma = strike_info.get('call_gamma', 0)
            put_gamma = strike_info.get('put_gamma', 0)
            call_oi = strike_info.get('call_oi', 0)
            put_oi = strike_info.get('put_oi', 0)

            # Calculate net gamma
            net_gamma = self.calculate_net_gamma(call_gamma, put_gamma, call_oi, put_oi)
            total_gamma += abs(net_gamma)
            total_net_gamma += net_gamma

            # Check for gamma flip
            prev_strike = previous_strikes.get(strike)
            prev_gamma = prev_strike.net_gamma if prev_strike else 0
            flipped, flip_dir = self.detect_gamma_flip(net_gamma, prev_gamma)

            if flipped:
                gamma_flips.append({
                    'strike': strike,
                    'direction': flip_dir,
                    'gamma_before': prev_gamma,
                    'gamma_after': net_gamma
                })

            # Update history for ROC calculation
            self.update_history(strike, net_gamma, timestamp)

            # Calculate ROC at multiple timeframes
            history = self.history.get(strike, [])
            roc_1min = self.calculate_roc(strike, net_gamma, history, minutes=1)
            roc_5min = self.calculate_roc(strike, net_gamma, history, minutes=5)
            roc_30min = self.calculate_roc(strike, net_gamma, history, minutes=30)
            roc_1hr = self.calculate_roc(strike, net_gamma, history, minutes=60)
            roc_4hr = self.calculate_roc(strike, net_gamma, history, minutes=240)
            roc_trading_day = self.calculate_roc_since_open(net_gamma, history)

            # Calculate gamma change percentage
            gamma_change_pct = 0
            if prev_gamma and prev_gamma != 0:
                gamma_change_pct = ((net_gamma - prev_gamma) / abs(prev_gamma)) * 100

            strike_data = StrikeData(
                strike=strike,
                net_gamma=net_gamma,
                call_gamma=call_gamma,
                put_gamma=put_gamma,
                gamma_change_pct=round(gamma_change_pct, 2),
                roc_1min=roc_1min,
                roc_5min=roc_5min,
                roc_30min=roc_30min,
                roc_1hr=roc_1hr,
                roc_4hr=roc_4hr,
                roc_trading_day=roc_trading_day,
                volume=strike_info.get('volume', 0),
                call_iv=strike_info.get('call_iv', 0),
                put_iv=strike_info.get('put_iv', 0),
                previous_net_gamma=prev_gamma,
                gamma_flipped=flipped,
                flip_direction=flip_dir
            )
            strikes_data.append(strike_data)

            # Calculate expected move from ATM
            if strike == atm_strike:
                call_price = strike_info.get('call_price', 0)
                put_price = strike_info.get('put_price', 0)
                expected_move = self.calculate_expected_move(call_price, put_price)

        # Default expected move if not calculated
        if expected_move == 0:
            expected_move = spot_price * 0.01  # 1% default

        # Calculate probabilities for all strikes
        for strike_data in strikes_data:
            strike_data.probability = self.calculate_probability_hybrid(
                strike_data.strike,
                spot_price,
                strike_data.net_gamma,
                total_gamma,
                expected_move
            )

        # Normalize probabilities to sum to 100%
        total_prob = sum(s.probability for s in strikes_data)
        if total_prob > 0:
            for s in strikes_data:
                s.probability = round((s.probability / total_prob) * 100, 1)

        # Classify overall regime
        gamma_regime = self.classify_gamma_regime(total_net_gamma)
        previous_regime = self.previous_snapshot.gamma_regime if self.previous_snapshot else None
        regime_flipped = previous_regime is not None and gamma_regime != previous_regime

        # Identify magnets, pin, and danger zones
        magnets = self.identify_magnets(strikes_data)
        likely_pin, pin_probability = self.identify_pin_strike(strikes_data, spot_price)
        danger_zones = self.identify_danger_zones(strikes_data)

        # Detect pinning condition (no danger zones = stable gamma = likely pinning)
        pinning_status = self.detect_pinning_condition(strikes_data, spot_price, likely_pin, danger_zones)

        # Create snapshot
        symbol = options_data.get('symbol', 'SPY')  # Get symbol from data, default to SPY
        snapshot = GammaSnapshot(
            symbol=symbol,
            expiration_date=expiration,
            snapshot_time=timestamp,
            spot_price=spot_price,
            expected_move=expected_move,
            vix=vix,
            total_net_gamma=total_net_gamma,
            gamma_regime=gamma_regime,
            previous_regime=previous_regime,
            regime_flipped=regime_flipped,
            market_status=market_status,
            strikes=strikes_data,
            magnets=magnets,
            likely_pin=likely_pin,
            pin_probability=pin_probability,
            danger_zones=danger_zones,
            gamma_flips=gamma_flips,
            pinning_status=pinning_status
        )

        # Generate alerts
        self.alerts = self.generate_alerts(snapshot, self.previous_snapshot)

        # Update state for next iteration
        self.previous_snapshot = snapshot
        self.previous_magnets = [m['strike'] for m in magnets]

        return snapshot

    def filter_strikes_by_expected_move(self, strikes: List[StrikeData],
                                         spot_price: float,
                                         expected_move: float,
                                         extra_strikes: int = 5) -> List[StrikeData]:
        """
        Filter strikes to only include those within expected move ± extra strikes.

        Args:
            strikes: All strike data
            spot_price: Current spot price
            expected_move: Expected move in dollars
            extra_strikes: Number of strikes outside expected move to include

        Returns:
            Filtered list of strikes
        """
        lower_bound = spot_price - expected_move
        upper_bound = spot_price + expected_move

        # Sort strikes by distance from bounds
        def in_range_priority(s):
            if lower_bound <= s.strike <= upper_bound:
                return 0
            elif s.strike < lower_bound:
                return lower_bound - s.strike
            else:
                return s.strike - upper_bound

        sorted_strikes = sorted(strikes, key=in_range_priority)

        # Get strikes within expected move
        in_range = [s for s in sorted_strikes if lower_bound <= s.strike <= upper_bound]

        # Get extra strikes outside
        outside_lower = sorted([s for s in strikes if s.strike < lower_bound],
                                key=lambda x: x.strike, reverse=True)[:extra_strikes]
        outside_upper = sorted([s for s in strikes if s.strike > upper_bound],
                                key=lambda x: x.strike)[:extra_strikes]

        # Combine and sort by strike
        all_strikes = in_range + outside_lower + outside_upper
        return sorted(all_strikes, key=lambda s: s.strike)

    def get_active_alerts(self) -> List[Dict]:
        """Get list of active (unacknowledged) alerts"""
        return [a.to_dict() for a in self.alerts]

    def acknowledge_alert(self, alert_index: int) -> bool:
        """Acknowledge an alert by index"""
        if 0 <= alert_index < len(self.alerts):
            # In production, this would update the database
            return True
        return False


# Singleton instance
_argus_engine: Optional[ArgusEngine] = None


def get_argus_engine() -> ArgusEngine:
    """Get or create the singleton ARGUS engine instance"""
    global _argus_engine
    if _argus_engine is None:
        _argus_engine = ArgusEngine()
    return _argus_engine


def initialize_argus_engine() -> ArgusEngine:
    """
    Initialize ARGUS engine with eager loading of ML models.
    Call this at application startup to avoid cold-start latency.
    """
    engine = get_argus_engine()
    # Eagerly load ML models to avoid first-request delay
    engine._get_ml_models()
    logger.info("ARGUS engine initialized with ML models pre-loaded")
    return engine
