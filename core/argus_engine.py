"""
ARGUS Engine - 0DTE Gamma Live Analysis
=========================================

Named after Argus Panoptes, the "all-seeing" giant with 100 eyes from Greek mythology.
Real-time visualization of net gamma by strike with ML-powered probability predictions.

Features:
- Net gamma calculation per strike
- Gamma flip detection (positive ↔ negative)
- Hybrid probability calculation (ML + gamma-weighted distance)
- Rate of change indicators (1-min and 5-min)
- Magnet, pin, and danger zone detection

Author: AlphaGEX Team
"""

import os
import sys
import logging
from datetime import datetime, timedelta, date
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field, asdict
from enum import Enum
import math
import json

import numpy as np
import pandas as pd

# Add parent directory for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from dotenv import load_dotenv
load_dotenv()

logger = logging.getLogger(__name__)


class GammaRegime(Enum):
    """Overall gamma regime classification"""
    POSITIVE = "POSITIVE"
    NEGATIVE = "NEGATIVE"
    NEUTRAL = "NEUTRAL"


class FlipDirection(Enum):
    """Direction of gamma flip"""
    POS_TO_NEG = "POS_TO_NEG"
    NEG_TO_POS = "NEG_TO_POS"


class DangerType(Enum):
    """Type of danger zone"""
    BUILDING = "BUILDING"      # Gamma accumulating rapidly (>+25% in 5 min)
    COLLAPSING = "COLLAPSING"  # Gamma evaporating (<-25% in 5 min)
    SPIKE = "SPIKE"            # Sudden gamma surge (>+15% in 1 min)


class AlertType(Enum):
    """Types of alerts"""
    GAMMA_FLIP = "GAMMA_FLIP"
    REGIME_CHANGE = "REGIME_CHANGE"
    GAMMA_SPIKE = "GAMMA_SPIKE"
    MAGNET_SHIFT = "MAGNET_SHIFT"
    PIN_ZONE_ENTRY = "PIN_ZONE_ENTRY"
    DANGER_ZONE = "DANGER_ZONE"
    GAMMA_COLLAPSE = "GAMMA_COLLAPSE"
    PATTERN_MATCH = "PATTERN_MATCH"


class AlertPriority(Enum):
    """Alert priority levels"""
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"


@dataclass
class StrikeData:
    """Data for a single strike"""
    strike: float
    net_gamma: float
    call_gamma: float = 0.0
    put_gamma: float = 0.0
    probability: float = 0.0
    gamma_change_pct: float = 0.0
    roc_1min: float = 0.0
    roc_5min: float = 0.0
    volume: int = 0
    call_iv: float = 0.0
    put_iv: float = 0.0
    is_magnet: bool = False
    magnet_rank: Optional[int] = None
    is_pin: bool = False
    is_danger: bool = False
    danger_type: Optional[str] = None
    gamma_flipped: bool = False
    flip_direction: Optional[str] = None
    previous_net_gamma: float = 0.0

    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class GammaSnapshot:
    """Complete gamma snapshot at a point in time"""
    symbol: str
    expiration_date: str
    snapshot_time: datetime
    spot_price: float
    expected_move: float
    vix: float
    total_net_gamma: float
    gamma_regime: str
    previous_regime: Optional[str]
    regime_flipped: bool
    market_status: str
    strikes: List[StrikeData]
    magnets: List[Dict]
    likely_pin: float
    pin_probability: float
    danger_zones: List[Dict]
    gamma_flips: List[Dict]

    def to_dict(self) -> Dict:
        return {
            'symbol': self.symbol,
            'expiration_date': self.expiration_date,
            'snapshot_time': self.snapshot_time.isoformat(),
            'spot_price': self.spot_price,
            'expected_move': self.expected_move,
            'vix': self.vix,
            'total_net_gamma': self.total_net_gamma,
            'gamma_regime': self.gamma_regime,
            'previous_regime': self.previous_regime,
            'regime_flipped': self.regime_flipped,
            'market_status': self.market_status,
            'strikes': [s.to_dict() for s in self.strikes],
            'magnets': self.magnets,
            'likely_pin': self.likely_pin,
            'pin_probability': self.pin_probability,
            'danger_zones': self.danger_zones,
            'gamma_flips': self.gamma_flips
        }


@dataclass
class Alert:
    """Alert generated by the system"""
    alert_type: str
    strike: Optional[float]
    message: str
    priority: str
    spot_price: float
    old_value: Optional[str] = None
    new_value: Optional[str] = None
    triggered_at: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> Dict:
        return {
            'alert_type': self.alert_type,
            'strike': self.strike,
            'message': self.message,
            'priority': self.priority,
            'spot_price': self.spot_price,
            'old_value': self.old_value,
            'new_value': self.new_value,
            'triggered_at': self.triggered_at.isoformat()
        }


class ArgusEngine:
    """
    Core engine for ARGUS 0DTE Gamma Live analysis.

    Responsibilities:
    - Fetch and process gamma data from Tradier
    - Calculate net gamma per strike
    - Detect gamma flips (positive ↔ negative)
    - Calculate probabilities using hybrid approach
    - Identify magnets, pins, and danger zones
    - Generate alerts for significant events
    """

    # Thresholds
    ROC_1MIN_SPIKE_THRESHOLD = 15.0  # % for SPIKE danger type
    ROC_5MIN_BUILDING_THRESHOLD = 25.0  # % for BUILDING danger type
    ROC_5MIN_COLLAPSING_THRESHOLD = -25.0  # % for COLLAPSING danger type
    PIN_ZONE_PROXIMITY_PCT = 0.5  # % distance from likely pin
    GAMMA_SPIKE_THRESHOLD = 50.0  # % increase in 5 min for alert
    GAMMA_COLLAPSE_THRESHOLD = -20.0  # % decrease in 10 min for alert

    def __init__(self):
        """Initialize the ARGUS engine"""
        self.previous_snapshot: Optional[GammaSnapshot] = None
        self.history: Dict[float, List[Tuple[datetime, float]]] = {}  # strike -> [(time, gamma)]
        self.previous_magnets: List[float] = []
        self.alerts: List[Alert] = []

        # Import ML models lazily to avoid circular imports
        self._ml_models = None

    def _get_ml_models(self):
        """Lazy load ML probability models"""
        if self._ml_models is None:
            try:
                from quant.gex_probability_models import GEXProbabilityModels
                self._ml_models = GEXProbabilityModels()
                logger.info("Loaded GEX probability models for ARGUS")
            except Exception as e:
                logger.warning(f"Could not load ML models: {e}")
                self._ml_models = False
        return self._ml_models if self._ml_models else None

    def get_market_status(self) -> str:
        """Determine current market status based on time"""
        now = datetime.now()
        # Convert to ET (simplified - assumes server is in ET or adjust as needed)
        hour = now.hour
        minute = now.minute

        # Weekend check
        if now.weekday() >= 5:
            return 'closed'

        time_minutes = hour * 60 + minute

        # Pre-market: 4:00am - 9:30am ET
        if 4 * 60 <= time_minutes < 9 * 60 + 30:
            return 'pre_market'
        # Market hours: 9:30am - 4:00pm ET
        elif 9 * 60 + 30 <= time_minutes < 16 * 60:
            return 'open'
        # After hours: 4:00pm - 8:00pm ET
        elif 16 * 60 <= time_minutes < 20 * 60:
            return 'after_hours'
        else:
            return 'closed'

    def get_0dte_expiration(self, target_day: str = 'today') -> str:
        """
        Get the 0DTE expiration date.
        SPY has 0DTE every day (Mon-Fri).

        Args:
            target_day: 'today', 'mon', 'tue', 'wed', 'thu', 'fri'

        Returns:
            Expiration date string in YYYY-MM-DD format
        """
        today = date.today()

        if target_day == 'today':
            # If weekend, return next Monday
            if today.weekday() >= 5:
                days_until_monday = 7 - today.weekday()
                return (today + timedelta(days=days_until_monday)).strftime('%Y-%m-%d')
            return today.strftime('%Y-%m-%d')

        # Map day names to weekday numbers
        day_map = {'mon': 0, 'tue': 1, 'wed': 2, 'thu': 3, 'fri': 4}
        target_weekday = day_map.get(target_day.lower(), today.weekday())

        # Calculate days until target
        days_ahead = target_weekday - today.weekday()
        if days_ahead < 0:
            days_ahead += 7

        target_date = today + timedelta(days=days_ahead)
        return target_date.strftime('%Y-%m-%d')

    def calculate_expected_move(self, atm_call_price: float, atm_put_price: float) -> float:
        """
        Calculate expected move from ATM straddle price.

        Args:
            atm_call_price: Price of ATM call
            atm_put_price: Price of ATM put

        Returns:
            Expected move in dollars
        """
        return atm_call_price + atm_put_price

    def calculate_net_gamma(self, call_gamma: float, put_gamma: float,
                            call_oi: int = 0, put_oi: int = 0) -> float:
        """
        Calculate net gamma at a strike.

        Net gamma = call_gamma * call_OI * 100 + put_gamma * put_OI * 100
        (Both should be positive as they measure absolute exposure)

        For visualization, we show the sum as net gamma affects dealer hedging.
        """
        # Gamma is always positive, but we multiply by OI and contract multiplier
        call_exposure = abs(call_gamma) * call_oi * 100 if call_oi else abs(call_gamma)
        put_exposure = abs(put_gamma) * put_oi * 100 if put_oi else abs(put_gamma)

        # Net gamma is typically calls - puts for directional bias
        # Positive = calls dominate (dealers hedging by buying)
        # Negative = puts dominate (dealers hedging by selling)
        return call_exposure - put_exposure

    def detect_gamma_flip(self, current_gamma: float, previous_gamma: float) -> Tuple[bool, Optional[str]]:
        """
        Detect if gamma flipped from positive to negative or vice versa.

        Returns:
            Tuple of (flipped: bool, direction: Optional[str])
        """
        if previous_gamma is None or previous_gamma == 0:
            return False, None

        # Check for sign change
        if current_gamma > 0 and previous_gamma < 0:
            return True, FlipDirection.NEG_TO_POS.value
        elif current_gamma < 0 and previous_gamma > 0:
            return True, FlipDirection.POS_TO_NEG.value

        return False, None

    def classify_gamma_regime(self, total_net_gamma: float) -> str:
        """
        Classify overall gamma regime based on total net gamma.

        Returns:
            POSITIVE, NEGATIVE, or NEUTRAL
        """
        # Threshold for neutral zone (can be tuned)
        neutral_threshold = 1e9  # $1B

        if total_net_gamma > neutral_threshold:
            return GammaRegime.POSITIVE.value
        elif total_net_gamma < -neutral_threshold:
            return GammaRegime.NEGATIVE.value
        else:
            return GammaRegime.NEUTRAL.value

    def calculate_probability_hybrid(self, strike: float, spot_price: float,
                                     net_gamma: float, total_gamma: float,
                                     expected_move: float,
                                     gamma_structure: Dict = None) -> float:
        """
        Calculate probability of price landing at a strike using hybrid approach.

        60% ML model + 40% gamma-weighted distance

        Args:
            strike: Strike price
            spot_price: Current spot price
            net_gamma: Net gamma at this strike
            total_gamma: Total absolute gamma across all strikes
            expected_move: Expected move in dollars
            gamma_structure: Optional structure for ML model

        Returns:
            Probability as percentage (0-100)
        """
        # Distance component (40% weight)
        distance_from_spot = abs(strike - spot_price)
        gamma_magnitude = abs(net_gamma)

        # Avoid division by zero
        if total_gamma == 0:
            total_gamma = 1

        # Gamma weight (higher gamma = more likely to attract)
        gamma_weight = gamma_magnitude / total_gamma

        # Distance decay (exponential decay based on expected move)
        if expected_move > 0:
            distance_decay = math.exp(-distance_from_spot / expected_move)
        else:
            distance_decay = 1.0 if distance_from_spot == 0 else 0.0

        distance_probability = gamma_weight * distance_decay * 100

        # ML component (60% weight) - try to use ML models
        ml_probability = distance_probability  # Default to distance if no ML

        ml_models = self._get_ml_models()
        if ml_models and gamma_structure:
            try:
                ml_result = ml_models.predict_magnet_attraction(
                    strike, spot_price, gamma_structure
                )
                if ml_result and 'probability' in ml_result:
                    ml_probability = ml_result['probability'] * 100
            except Exception as e:
                logger.debug(f"ML prediction failed, using distance only: {e}")

        # Combined probability
        combined = (0.6 * ml_probability) + (0.4 * distance_probability)

        return combined

    def calculate_roc(self, strike: float, current_gamma: float,
                      history: List[Tuple[datetime, float]],
                      minutes: int = 1) -> float:
        """
        Calculate rate of change for a strike over specified minutes.

        Args:
            strike: Strike price
            current_gamma: Current gamma value
            history: List of (timestamp, gamma) tuples
            minutes: Number of minutes to look back (1 or 5)

        Returns:
            Rate of change as percentage
        """
        if not history or len(history) < 2:
            return 0.0

        # Find value from X minutes ago
        target_time = datetime.now() - timedelta(minutes=minutes)
        old_gamma = None

        for timestamp, gamma in reversed(history):
            if timestamp <= target_time:
                old_gamma = gamma
                break

        if old_gamma is None or old_gamma == 0:
            return 0.0

        roc = ((current_gamma - old_gamma) / abs(old_gamma)) * 100
        return round(roc, 2)

    def update_history(self, strike: float, gamma: float, timestamp: datetime = None):
        """Update gamma history for a strike"""
        if timestamp is None:
            timestamp = datetime.now()

        if strike not in self.history:
            self.history[strike] = []

        self.history[strike].append((timestamp, gamma))

        # Keep only last 30 minutes of history
        cutoff = timestamp - timedelta(minutes=30)
        self.history[strike] = [
            (t, g) for t, g in self.history[strike] if t >= cutoff
        ]

    def identify_magnets(self, strikes: List[StrikeData], top_n: int = 3) -> List[Dict]:
        """
        Identify top N gamma magnets (strikes with highest absolute gamma).

        Returns:
            List of dicts with strike and gamma info
        """
        sorted_strikes = sorted(strikes, key=lambda s: abs(s.net_gamma), reverse=True)

        magnets = []
        for i, strike_data in enumerate(sorted_strikes[:top_n]):
            magnets.append({
                'rank': i + 1,
                'strike': strike_data.strike,
                'net_gamma': strike_data.net_gamma,
                'probability': strike_data.probability
            })
            strike_data.is_magnet = True
            strike_data.magnet_rank = i + 1

        return magnets

    def identify_pin_strike(self, strikes: List[StrikeData], spot_price: float) -> Tuple[float, float]:
        """
        Identify the likely pin strike.

        Pin score = (probability * 0.4) + (gamma_rank * 0.3) + (proximity_score * 0.3)

        Returns:
            Tuple of (pin_strike, pin_probability)
        """
        if not strikes:
            return 0.0, 0.0

        best_pin = None
        best_score = -1

        # Rank strikes by gamma
        sorted_by_gamma = sorted(strikes, key=lambda s: abs(s.net_gamma), reverse=True)
        gamma_ranks = {s.strike: i + 1 for i, s in enumerate(sorted_by_gamma)}

        for strike_data in strikes:
            # Probability component (0-1, higher is better)
            prob_score = strike_data.probability / 100

            # Gamma rank component (1 is best, invert so higher is better)
            gamma_rank = gamma_ranks.get(strike_data.strike, len(strikes))
            gamma_score = 1 - (gamma_rank / len(strikes))

            # Proximity score (closer to spot is better)
            distance = abs(strike_data.strike - spot_price)
            max_distance = max(abs(s.strike - spot_price) for s in strikes) or 1
            proximity_score = 1 - (distance / max_distance)

            # Combined score
            pin_score = (prob_score * 0.4) + (gamma_score * 0.3) + (proximity_score * 0.3)

            if pin_score > best_score:
                best_score = pin_score
                best_pin = strike_data

        if best_pin:
            best_pin.is_pin = True
            return best_pin.strike, best_pin.probability

        return 0.0, 0.0

    def identify_danger_zones(self, strikes: List[StrikeData]) -> List[Dict]:
        """
        Identify danger zones - strikes with rapid gamma changes.

        Thresholds:
        - BUILDING: 5-min ROC > +25%
        - COLLAPSING: 5-min ROC < -25%
        - SPIKE: 1-min ROC > +15%
        """
        danger_zones = []

        for strike_data in strikes:
            danger_type = None

            if strike_data.roc_5min >= self.ROC_5MIN_BUILDING_THRESHOLD:
                danger_type = DangerType.BUILDING.value
            elif strike_data.roc_5min <= self.ROC_5MIN_COLLAPSING_THRESHOLD:
                danger_type = DangerType.COLLAPSING.value
            elif strike_data.roc_1min >= self.ROC_1MIN_SPIKE_THRESHOLD:
                danger_type = DangerType.SPIKE.value

            if danger_type:
                strike_data.is_danger = True
                strike_data.danger_type = danger_type
                danger_zones.append({
                    'strike': strike_data.strike,
                    'danger_type': danger_type,
                    'roc_1min': strike_data.roc_1min,
                    'roc_5min': strike_data.roc_5min
                })

        return danger_zones

    def generate_alerts(self, current: GammaSnapshot, previous: Optional[GammaSnapshot]) -> List[Alert]:
        """
        Generate alerts based on current snapshot vs previous.
        """
        alerts = []

        # 1. Gamma Flip alerts
        for flip in current.gamma_flips:
            alert = Alert(
                alert_type=AlertType.GAMMA_FLIP.value,
                strike=flip['strike'],
                message=f"Strike {flip['strike']} gamma flipped {flip['direction']}",
                priority=AlertPriority.HIGH.value,
                spot_price=current.spot_price,
                old_value=str(flip.get('gamma_before', 'N/A')),
                new_value=str(flip.get('gamma_after', 'N/A'))
            )
            alerts.append(alert)

        # 2. Regime Change alert
        if current.regime_flipped and previous:
            alert = Alert(
                alert_type=AlertType.REGIME_CHANGE.value,
                strike=None,
                message=f"Gamma regime shifted from {previous.gamma_regime} to {current.gamma_regime}",
                priority=AlertPriority.HIGH.value,
                spot_price=current.spot_price,
                old_value=previous.gamma_regime,
                new_value=current.gamma_regime
            )
            alerts.append(alert)

        # 3. Magnet Shift alert
        if previous and current.magnets:
            current_top = current.magnets[0]['strike'] if current.magnets else None
            previous_top = self.previous_magnets[0] if self.previous_magnets else None

            if current_top and previous_top and current_top != previous_top:
                alert = Alert(
                    alert_type=AlertType.MAGNET_SHIFT.value,
                    strike=current_top,
                    message=f"Top magnet shifted from {previous_top} to {current_top}",
                    priority=AlertPriority.HIGH.value,
                    spot_price=current.spot_price,
                    old_value=str(previous_top),
                    new_value=str(current_top)
                )
                alerts.append(alert)

        # 4. Danger Zone alerts
        for dz in current.danger_zones:
            alert = Alert(
                alert_type=AlertType.DANGER_ZONE.value,
                strike=dz['strike'],
                message=f"Strike {dz['strike']} entered {dz['danger_type']} zone (ROC: {dz['roc_5min']:.1f}%)",
                priority=AlertPriority.MEDIUM.value,
                spot_price=current.spot_price,
                new_value=dz['danger_type']
            )
            alerts.append(alert)

        # 5. Pin Zone Entry alert
        if current.likely_pin:
            distance_to_pin = abs(current.spot_price - current.likely_pin)
            pin_zone_threshold = current.spot_price * (self.PIN_ZONE_PROXIMITY_PCT / 100)

            if distance_to_pin <= pin_zone_threshold:
                alert = Alert(
                    alert_type=AlertType.PIN_ZONE_ENTRY.value,
                    strike=current.likely_pin,
                    message=f"SPY entered pin zone near {current.likely_pin} strike",
                    priority=AlertPriority.MEDIUM.value,
                    spot_price=current.spot_price
                )
                alerts.append(alert)

        # 6. Gamma Spike alerts
        for strike_data in current.strikes:
            if previous:
                # Find previous strike data
                prev_strike = next(
                    (s for s in previous.strikes if s.strike == strike_data.strike),
                    None
                )
                if prev_strike and prev_strike.net_gamma != 0:
                    change_pct = ((strike_data.net_gamma - prev_strike.net_gamma) /
                                  abs(prev_strike.net_gamma)) * 100
                    if change_pct >= self.GAMMA_SPIKE_THRESHOLD:
                        alert = Alert(
                            alert_type=AlertType.GAMMA_SPIKE.value,
                            strike=strike_data.strike,
                            message=f"Strike {strike_data.strike} gamma spiked +{change_pct:.0f}%",
                            priority=AlertPriority.HIGH.value,
                            spot_price=current.spot_price,
                            old_value=str(prev_strike.net_gamma),
                            new_value=str(strike_data.net_gamma)
                        )
                        alerts.append(alert)

        return alerts

    def process_options_chain(self, options_data: Dict, spot_price: float,
                               vix: float, expiration: str) -> GammaSnapshot:
        """
        Process raw options chain data into a GammaSnapshot.

        Args:
            options_data: Dict containing options chain from Tradier
            spot_price: Current spot price
            vix: Current VIX level
            expiration: Expiration date string

        Returns:
            GammaSnapshot with all calculated metrics
        """
        timestamp = datetime.now()
        market_status = self.get_market_status()

        # Extract strikes and calculate metrics
        strikes_data = []
        total_gamma = 0
        total_net_gamma = 0
        gamma_flips = []

        # Get previous strike data for comparison
        previous_strikes = {}
        if self.previous_snapshot:
            for s in self.previous_snapshot.strikes:
                previous_strikes[s.strike] = s

        # Calculate expected move from ATM options
        expected_move = 0
        atm_strike = round(spot_price)  # Simplified ATM finding

        # Process each strike from options data
        for strike_info in options_data.get('strikes', []):
            strike = strike_info.get('strike', 0)
            call_gamma = strike_info.get('call_gamma', 0)
            put_gamma = strike_info.get('put_gamma', 0)
            call_oi = strike_info.get('call_oi', 0)
            put_oi = strike_info.get('put_oi', 0)

            # Calculate net gamma
            net_gamma = self.calculate_net_gamma(call_gamma, put_gamma, call_oi, put_oi)
            total_gamma += abs(net_gamma)
            total_net_gamma += net_gamma

            # Check for gamma flip
            prev_strike = previous_strikes.get(strike)
            prev_gamma = prev_strike.net_gamma if prev_strike else 0
            flipped, flip_dir = self.detect_gamma_flip(net_gamma, prev_gamma)

            if flipped:
                gamma_flips.append({
                    'strike': strike,
                    'direction': flip_dir,
                    'gamma_before': prev_gamma,
                    'gamma_after': net_gamma
                })

            # Update history for ROC calculation
            self.update_history(strike, net_gamma, timestamp)

            # Calculate ROC
            history = self.history.get(strike, [])
            roc_1min = self.calculate_roc(strike, net_gamma, history, minutes=1)
            roc_5min = self.calculate_roc(strike, net_gamma, history, minutes=5)

            # Calculate gamma change percentage
            gamma_change_pct = 0
            if prev_gamma and prev_gamma != 0:
                gamma_change_pct = ((net_gamma - prev_gamma) / abs(prev_gamma)) * 100

            strike_data = StrikeData(
                strike=strike,
                net_gamma=net_gamma,
                call_gamma=call_gamma,
                put_gamma=put_gamma,
                gamma_change_pct=round(gamma_change_pct, 2),
                roc_1min=roc_1min,
                roc_5min=roc_5min,
                volume=strike_info.get('volume', 0),
                call_iv=strike_info.get('call_iv', 0),
                put_iv=strike_info.get('put_iv', 0),
                previous_net_gamma=prev_gamma,
                gamma_flipped=flipped,
                flip_direction=flip_dir
            )
            strikes_data.append(strike_data)

            # Calculate expected move from ATM
            if strike == atm_strike:
                call_price = strike_info.get('call_price', 0)
                put_price = strike_info.get('put_price', 0)
                expected_move = self.calculate_expected_move(call_price, put_price)

        # Default expected move if not calculated
        if expected_move == 0:
            expected_move = spot_price * 0.01  # 1% default

        # Calculate probabilities for all strikes
        for strike_data in strikes_data:
            strike_data.probability = self.calculate_probability_hybrid(
                strike_data.strike,
                spot_price,
                strike_data.net_gamma,
                total_gamma,
                expected_move
            )

        # Normalize probabilities to sum to 100%
        total_prob = sum(s.probability for s in strikes_data)
        if total_prob > 0:
            for s in strikes_data:
                s.probability = round((s.probability / total_prob) * 100, 1)

        # Classify overall regime
        gamma_regime = self.classify_gamma_regime(total_net_gamma)
        previous_regime = self.previous_snapshot.gamma_regime if self.previous_snapshot else None
        regime_flipped = previous_regime is not None and gamma_regime != previous_regime

        # Identify magnets, pin, and danger zones
        magnets = self.identify_magnets(strikes_data)
        likely_pin, pin_probability = self.identify_pin_strike(strikes_data, spot_price)
        danger_zones = self.identify_danger_zones(strikes_data)

        # Create snapshot
        snapshot = GammaSnapshot(
            symbol='SPY',
            expiration_date=expiration,
            snapshot_time=timestamp,
            spot_price=spot_price,
            expected_move=expected_move,
            vix=vix,
            total_net_gamma=total_net_gamma,
            gamma_regime=gamma_regime,
            previous_regime=previous_regime,
            regime_flipped=regime_flipped,
            market_status=market_status,
            strikes=strikes_data,
            magnets=magnets,
            likely_pin=likely_pin,
            pin_probability=pin_probability,
            danger_zones=danger_zones,
            gamma_flips=gamma_flips
        )

        # Generate alerts
        self.alerts = self.generate_alerts(snapshot, self.previous_snapshot)

        # Update state for next iteration
        self.previous_snapshot = snapshot
        self.previous_magnets = [m['strike'] for m in magnets]

        return snapshot

    def filter_strikes_by_expected_move(self, strikes: List[StrikeData],
                                         spot_price: float,
                                         expected_move: float,
                                         extra_strikes: int = 5) -> List[StrikeData]:
        """
        Filter strikes to only include those within expected move ± extra strikes.

        Args:
            strikes: All strike data
            spot_price: Current spot price
            expected_move: Expected move in dollars
            extra_strikes: Number of strikes outside expected move to include

        Returns:
            Filtered list of strikes
        """
        lower_bound = spot_price - expected_move
        upper_bound = spot_price + expected_move

        # Sort strikes by distance from bounds
        def in_range_priority(s):
            if lower_bound <= s.strike <= upper_bound:
                return 0
            elif s.strike < lower_bound:
                return lower_bound - s.strike
            else:
                return s.strike - upper_bound

        sorted_strikes = sorted(strikes, key=in_range_priority)

        # Get strikes within expected move
        in_range = [s for s in sorted_strikes if lower_bound <= s.strike <= upper_bound]

        # Get extra strikes outside
        outside_lower = sorted([s for s in strikes if s.strike < lower_bound],
                                key=lambda x: x.strike, reverse=True)[:extra_strikes]
        outside_upper = sorted([s for s in strikes if s.strike > upper_bound],
                                key=lambda x: x.strike)[:extra_strikes]

        # Combine and sort by strike
        all_strikes = in_range + outside_lower + outside_upper
        return sorted(all_strikes, key=lambda s: s.strike)

    def get_active_alerts(self) -> List[Dict]:
        """Get list of active (unacknowledged) alerts"""
        return [a.to_dict() for a in self.alerts]

    def acknowledge_alert(self, alert_index: int) -> bool:
        """Acknowledge an alert by index"""
        if 0 <= alert_index < len(self.alerts):
            # In production, this would update the database
            return True
        return False


# Singleton instance
_argus_engine: Optional[ArgusEngine] = None


def get_argus_engine() -> ArgusEngine:
    """Get or create the singleton ARGUS engine instance"""
    global _argus_engine
    if _argus_engine is None:
        _argus_engine = ArgusEngine()
    return _argus_engine
